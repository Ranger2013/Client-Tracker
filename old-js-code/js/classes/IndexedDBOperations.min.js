// @ts-nocheck
import{errorLogAPI}from"../utils/network/apiEndpoints.js";import{logServerSideError}from"../utils/network/network.js";export default class IndexedDBOperations{constructor(){this.dbName="ClientTrackerDB",this.version=1}stores={MAXCLIENTID:"max_client_id",MAXCLIENTPRIMARYKEY:"max_client_primary_key",ADDCLIENT:"backup_add_client",EDITCLIENT:"backup_edit_client",DELETECLIENT:"backup_delete_client",ADDDUPLICATECLIENT:"backup_add_duplicate_client",DELETEDUPLICATECLIENT:"backup_delete_duplicate_client",USERSETTINGS:"user_settings",CLIENTLIST:"client_list",TRIMMING:"trimmings",MAXHORSEID:"max_horse_id",ADDHORSE:"backup_add_horse",EDITHORSE:"backup_edit_horse",DELETEHORSE:"backup_delete_horse",MAXTRIMID:"max_trim_id",ADDTRIMMING:"backup_add_trimming",EDITTRIMMING:"backup_edit_trimming",DELETETRIMMING:"backup_delete_trimming",ADDMILEAGE:"backup_add_mileage",EDITMILEAGE:"backup_edit_mileage",DELETEMILEAGE:"backup_delete_mileage",ADDEXPENSES:"backup_add_expenses",EDITEXPENSES:"backup_edit_expenses",DELETEEXPENSES:"backup_delete_expenses",PERSONALNOTES:"personal_notes",MAXPERSONALNOTESID:"max_personal_notes_id",ADDPERSONALNOTES:"backup_add_personal_notes",EDITPERSONALNOTES:"backup_edit_personal_notes",DELETEPERSONALNOTES:"backup_delete_personal_notes",DATETIME:"backup_date_time",FARRIERPRICES:"backup_farrier_prices",MILEAGECHARGES:"backup_mileage_charges",SCHEDULINGOPTIONS:"backup_scheduling_options",COLOROPTIONS:"backup_color_options"};upgradedNeeded(e){const r=e.target.result,t=e.target.transaction,o={CLIENTLIST:{keyPath:"primaryKey",autoIncrement:!1,indexes:[{name:"cID",keyPath:"cID",unique:!1},{name:"trim_date",keyPath:"trim_date",unique:!1}]},ADDCLIENT:{keyPath:"cID",autoIncrement:!1,unique:!0},EDITCLIENT:{keyPath:"primaryKey",unique:!0},DELETECLIENT:{keyPath:"cID"},ADDDUPLICATECLIENT:{keyPath:"primaryKey",unique:!0},DELETEDUPLICATECLIENT:{keyPath:"primaryKey",unique:!0},MAXCLIENTPRIMARYKEY:{keyPath:"primaryKey",unique:!0},MAXCLIENTID:{keyPath:"cID",unique:!0},TRIMMING:{keyPath:"cID",unique:!0},MAXTRIMID:{keyPath:"trimID",unique:!0},ADDTRIMMING:{keyPath:"trimID",unique:!0},EDITTRIMMING:{keyPath:"cID"},DELETETRIMMING:{keyPath:"cID"},EDITMILEAGE:{keyPath:"mileageID",unique:!0},DELETEMILEAGE:{keyPath:"mileageID",unique:!0},EDITEXPENSES:{keyPath:"expID",unique:!0},DELETEEXPENSES:{keyPath:"expID",unique:!0},PERSONALNOTES:{keyPath:"notesID",unique:!0},ADDPERSONALNOTES:{keyPath:"notesID",unique:!0},EDITPERSONALNOTES:{keyPath:"notesID",unique:!0},DELETEPERSONALNOTES:{keyPath:"notesID",unique:!0},MAXPERSONALNOTESID:{keyPath:"notesID",unique:!0},MAXHORSEID:{keyPath:"hID",unique:!0},ADDHORSE:{keyPath:"hID",autoIncrement:!0,unique:!0},EDITHORSE:{keyPath:"hID"},DELETEHORSE:{keyPath:"hID"},DEFAULT:{autoIncrement:!0}};for(let e in this.stores)if(this.stores.hasOwnProperty(e)){const a=this.stores[e],n=o[e]||o.DEFAULT;if(r.objectStoreNames.contains(a)){const e=t.objectStore(a);this.hasConfigChanged(e,n)&&this.updateStore(r,t,a,n)}else this.createStore(r,a,n)}}createStore(e,r,t){const o=e.createObjectStore(r,t);t.indexes&&t.indexes.forEach((e=>{o.createIndex(e.name,e.keyPath,{unique:e.unique})}))}hasConfigChanged(e,r){return JSON.stringify(e.keyPath)!==JSON.stringify(r.keyPath)||e.autoIncrement!==r.autoIncrement}updateStore(e,r,t,o){const a=r.objectStore(t),n=a.getAll();n.onsuccess=()=>{const r=n.result;e.deleteObjectStore(t),this.createStore(e,t,o),r.forEach((e=>a.add(e)))}}openDBPromise(){return new Promise(((e,r)=>{const t=indexedDB.open(this.dbName,this.version);t.onupgradeneeded=e=>{try{this.upgradedNeeded(e)}catch(e){console.error("Upgrade error:",e),r(new Error(`Database upgrade failed: ${e.message}`))}},t.onsuccess=r=>{e(r.target.result)},t.onerror=e=>{console.error("Database error:",e.target.error),r(new Error(`Database open failed: ${e.target.error.message}`))},t.onblocked=e=>{console.error("Database blocked:",e),r(new Error("Database blocked - close other tabs"))}}))}transReadWrite(e,r,t=null){try{const o=t||e.transaction(r,"readwrite");return o.onerror=e=>{console.error(`Transaction error in store ${r}:`,e),o.abort()},o.objectStore(r)}catch(e){console.warn(`Error with the transaction for ${r} store.`),logServerSideError(errorLogAPI,e,"transReadWriteError")}}transReadOnly(e,r,t=null){try{return(t||e.transaction(r,"readonly")).objectStore(r)}catch(e){const t=`Failed to access object store "${r}": ${e.message}`,o=new Error(t);throw o.stack=e.stack,o.name=e.name,logServerSideError(errorLogAPI,o,"transReadOnlyError"),new Error(t)}}getLastKeyForID(e){return new Promise((async(r,t)=>{const o=(await this.openDBPromise()).transaction(e).objectStore(e).openCursor(null,"prev");o.onsuccess=e=>{const t=e.target.result;r(t?t.key+1:1)},o.onerror=r=>{logServerSideError(errorLogAPI,r,"getLastKeyForID"),t(`Error getting the last key from ${e}: `+r)}}))}addStorePromise(e,r,t,o=!1,a){return new Promise(((n,s)=>{const i=this.transReadWrite(e,t,a);o&&i.clear();const c=i.add(r);c.onsuccess=e=>n(e.target.result),c.onerror=e=>{logServerSideError(errorLogAPI,e,"addStorePromise"),s(`Error adding data to ${t}: `+e)}}))}putStorePromise(e,r,t,o=!1,a){return new Promise((async(n,s)=>{try{const i=this.transReadWrite(e,t,a);o&&i.clear();const c=i.put(r);c.onsuccess=()=>n(c.result),c.onerror=async e=>{await logServerSideError(errorLogAPI,e,"putStorePromise"),s(`Error retrieving data from ${t}: `+e)}}catch(e){console.warn(`Error putting data into ${t}:`,e),await logServerSideError(errorLogAPI,e,"putStorePromise"),s(`Error retrieving data from ${t}: `+e)}}))}putStorePromiseWithKey(e,r,t,o=void 0,a=!1,n){return new Promise((async(s,i)=>{try{const c=this.transReadWrite(e,t,n);a&&c.clear();const E=c.put(r,o);E.onsuccess=()=>s(E.result),E.onerror=async e=>{i(`Error retrieving data from ${t}: `+e)}}catch(e){console.warn(`Error putting data into ${t}:`,e),logServerSideError(errorLogAPI,e,"putStorePromise")}}))}getStorePromise(e,r,t,o){return new Promise(((a,n)=>{let s=this.transReadOnly(e,r,o).get(t);s.onsuccess=e=>{a(e.target.result)},s.onerror=e=>{n(`Error retrieving data from ${r}: `+e)}}))}getAllStorePromise(e,r){return new Promise(((t,o)=>{const a=this.transReadOnly(e,r).getAll();a.onsuccess=e=>{t(e.target.result)},a.onerror=e=>{o(`Error retrieving data from ${r}: `+e.target.error)}}))}getAllStoreByIndexPromise(e,r,t,o,a){return new Promise(((n,s)=>{const i=this.transReadOnly(e,r,a).index(t).openCursor(IDBKeyRange.only(o)),c=[];i.onsuccess=e=>{const r=e.target.result;r?(c.push({...r.value}),r.continue()):n(c)},i.onerror=e=>{console.warn(`In getAllStoreByIndexPromise: error: store: ${r}: `,e),s(`Error retrieving data from ${r}: `+e)}}))}clearStorePromise(e,r,t){return new Promise(((o,a)=>{const n=this.transReadWrite(e,r,t).clear();n.onsuccess=()=>o(n.result),n.onerror=e=>a(`Error: Could not clear ${r}: `+e)}))}async addIndexDBPromise(e,r,t=null,o=null){try{const a=await(o instanceof IDBTransaction?o.db:this.openDBPromise());t&&await this.clearStorePromise(a,r);await this.addStorePromise(a,e,r,o)}catch(e){throw console.error("Error in addIndexDBPromise: ",e),e}}async putIndexDBPromise(e,r,t=null){try{const o=await(t instanceof IDBTransaction?t.db:this.openDBPromise()),a=this.putStore(o,e,r,t);await new Promise(((e,r)=>{a.onsuccess=e,a.onerror=r}))}catch(e){throw console.error("Error in putIndexDBPromise: ",e),e}}async deleteRecordPromise(e,r,t=null){try{const o=await(t instanceof IDBTransaction?t.db:this.openDBPromise()),a=this.transReadWrite(o,r,t).delete(e);return await new Promise(((e,t)=>{a.onsuccess=()=>{e(!0)},a.onerror=e=>t(`Error deleting record from ${r}: `+e)}))}catch(e){throw console.error("Error in deleteRecordPromise:",e),e}}async deleteIDBDatabasePromise(){return new Promise(((e,r)=>{const t=indexedDB.deleteDatabase(this.dbName);t.onsuccess=()=>{e(!0)},t.onerror=()=>{e(!1)}}))}}