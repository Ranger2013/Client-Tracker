// @ts-nocheck
export default class IndexedDBOperations{static#e=null;#r="ClientTrackerDB";#t=1;#a=null;#o=!1;constructor(e={debug:!1}){return IndexedDBOperations.#e?(void 0!==e.debug&&IndexedDBOperations.#e.setDebugMode(e.debug),IndexedDBOperations.#e):(this.#o=e.debug,IndexedDBOperations.#e=this,this.#s("IndexedDBOperations singleton instance created"),this)}#s(...e){this.#o&&console.log("[IndexedDBOperations]",...e)}setDebugMode(e){this.#o=!!e}#n={CLIENTLIST:{keyPath:"primaryKey",indexes:[{name:"cID",keyPath:"cID",unique:!1},{name:"trim_date",keyPath:"trim_date",unique:!1}]},MAXCLIENTID:{keyPath:"cID",unique:!0},MAXCLIENTPRIMARYKEY:{keyPath:"primaryKey",unique:!0},ADDCLIENT:{keyPath:"cID",unique:!0},EDITCLIENT:{keyPath:"primaryKey",unique:!0},DELETECLIENT:{keyPath:"cID"},ADDDUPLICATECLIENT:{keyPath:"primaryKey",unique:!0},DELETEDUPLICATECLIENT:{keyPath:"primaryKey",unique:!0},TRIMMING:{keyPath:"cID",unique:!0},MAXTRIMID:{keyPath:"trimID",unique:!0},ADDTRIMMING:{keyPath:"trimID",unique:!0},EDITTRIMMING:{keyPath:"cID"},DELETETRIMMING:{keyPath:"cID"},EDITMILEAGE:{keyPath:"mileageID",unique:!0},DELETEMILEAGE:{keyPath:"mileageID",unique:!0},EDITEXPENSES:{keyPath:"expID",unique:!0},DELETEEXPENSES:{keyPath:"expID",unique:!0},PERSONALNOTES:{keyPath:"notesID",unique:!0},ADDPERSONALNOTES:{keyPath:"notesID",unique:!0},EDITPERSONALNOTES:{keyPath:"notesID",unique:!0},DELETEPERSONALNOTES:{keyPath:"notesID",unique:!0},MAXPERSONALNOTESID:{keyPath:"notesID",unique:!0},MAXHORSEID:{keyPath:"hID",unique:!0},ADDHORSE:{keyPath:"hID",autoIncrement:!0,unique:!0},EDITHORSE:{keyPath:"hID"},DELETEHORSE:{keyPath:"hID"},USERSETTINGS:{autoIncrement:!0},DATETIME:{autoIncrement:!0},FARRIERPRICES:{autoIncrement:!0},MILEAGECHARGES:{autoIncrement:!0},SCHEDULINGOPTIONS:{autoIncrement:!0},COLOROPTIONS:{autoIncrement:!0},ERRORQUEUE:{autoIncrement:!0},DEFAULT:{autoIncrement:!0}};stores={MAXCLIENTID:"max_client_id",MAXCLIENTPRIMARYKEY:"max_client_primary_key",ADDCLIENT:"backup_add_client",EDITCLIENT:"backup_edit_client",DELETECLIENT:"backup_delete_client",ADDDUPLICATECLIENT:"backup_add_duplicate_client",DELETEDUPLICATECLIENT:"backup_delete_duplicate_client",USERSETTINGS:"user_settings",CLIENTLIST:"client_list",TRIMMING:"trimmings",MAXHORSEID:"max_horse_id",ADDHORSE:"backup_add_horse",EDITHORSE:"backup_edit_horse",DELETEHORSE:"backup_delete_horse",MAXTRIMID:"max_trim_id",ADDTRIMMING:"backup_add_trimming",EDITTRIMMING:"backup_edit_trimming",DELETETRIMMING:"backup_delete_trimming",ADDMILEAGE:"backup_add_mileage",EDITMILEAGE:"backup_edit_mileage",DELETEMILEAGE:"backup_delete_mileage",ADDEXPENSES:"backup_add_expenses",EDITEXPENSES:"backup_edit_expenses",DELETEEXPENSES:"backup_delete_expenses",PERSONALNOTES:"personal_notes",MAXPERSONALNOTESID:"max_personal_notes_id",ADDPERSONALNOTES:"backup_add_personal_notes",EDITPERSONALNOTES:"backup_edit_personal_notes",DELETEPERSONALNOTES:"backup_delete_personal_notes",DATETIME:"backup_date_time",FARRIERPRICES:"backup_farrier_prices",MILEAGECHARGES:"backup_mileage_charges",SCHEDULINGOPTIONS:"backup_scheduling_options",COLOROPTIONS:"backup_color_options",ERRORQUEUE:"error_queue"};async#i({consoleMsg:e,err:r,userMsg:t}){const{AppError:a}=await import("../errors/models/AppError.js");await a.process(r,{errorCode:a.Types.DATABASE_ERROR,userMessage:t,displayTarget:"page-msg"},!0)}async openDBPromise(){try{return this.#a||(this.#a=await new Promise(((e,r)=>{const t=indexedDB.open(this.#r,this.#t);t.onupgradeneeded=e=>this.#c(e),t.onsuccess=r=>e(r.target.result),t.onerror=()=>r(new Error("Failed to open database")),t.onblocked=()=>r(new Error("Database blocked - close other tabs"))}))),this.#a}catch(e){await this.#i({consoleMsg:"Database open failed: ",err:e,userMsg:"Unable to access local storage"})}}#c(e){const r=e.target.result;for(const[e,t]of Object.entries(this.stores))if(!r.objectStoreNames.contains(t)){const a=this.#n[e]??this.#n.DEFAULT;this.createStore(r,t,a)}}createStore(e,r,t){const a=e.createObjectStore(r,t);t.indexes&&t.indexes.forEach((e=>{a.createIndex(e.name,e.keyPath,{unique:e.unique})}))}async transReadWrite(e,r,t=null){try{const a=t||e.transaction(r,"readwrite");return a.onerror=e=>{console.error(`Transaction error in store ${r}:`,e),a.abort()},a.objectStore(r)}catch(e){await this.#i({consoleMsg:`Transaction error in store ${r}: `,err:e,userMsg:"Unable to access storage"})}}async transReadOnly(e,r,t=null){try{return(t||e.transaction(r,"readonly")).objectStore(r)}catch(e){await this.#i({consoleMsg:`Failed to access store ${r}: `,err:e,userMsg:"Unable to read from storage"})}}async getLastKeyForID({store:e,tx:r=null}){try{if(this.#s("Getting last key for store:",e),!e)throw new Error("Store name required");const t=r?.db||await this.openDBPromise(),a=await this.transReadOnly(t,e,r);return new Promise(((e,r)=>{const t=a.openCursor(null,"prev");t.onerror=e=>{this.#s("Cursor error:",e.target.error),r(e.target.error)},t.onsuccess=r=>{const t=r.target.result;this.#s("Cursor result:",t?.key);const a=t?t.key+1:1;this.#s("Next ID:",a),e(a)}}))}catch(e){this.#s("Error in getLastKeyForID:",e),await this.#i({consoleMsg:"Failed to get last key:",err:e,userMsg:"Unable to generate new ID"})}}async addStorePromise(e,r,t,a=!1,o){try{if(!e)throw new Error("Database instance required");if(!t)throw new Error("Store name required");if(!r)throw new Error("No data provided for store operation");const s=await this.transReadWrite(e,t,o);return new Promise(((e,t)=>{if(a){const a=s.clear();a.onerror=e=>t(e.target.error),a.onsuccess=()=>{const a=s.add(r);a.onsuccess=r=>e(r.target.result),a.onerror=e=>t(e.target.error)}}else{const a=s.add(r);a.onsuccess=r=>e(r.target.result),a.onerror=e=>t(e.target.error)}}))}catch(e){await this.#i({consoleMsg:"Error in addStorePromise operation: ",err:e,userMsg:"Unable to add data to the database."})}}async putStorePromise(e,r,t,a=!1,o){try{if(!e)throw new Error("Database instance required");if(!t)throw new Error("Store name required");if(!r)throw new Error("No data provided for store operation");const s=await this.transReadWrite(e,t,o);return new Promise(((e,t)=>{if(a){const a=s.clear();a.onerror=e=>t(e.target.error),a.onsuccess=()=>{const a=s.put(r);a.onsuccess=r=>e(r.target.result),a.onerror=e=>t(e.target.error)}}else{const a=s.put(r);a.onsuccess=r=>e(r.target.result),a.onerror=e=>t(e.target.error)}}))}catch(e){await this.#i({consoleMsg:"Error in putStorePromise database operation: ",err:e,userMsg:"Unable to save your data at this time."})}}getStorePromise(e,r,t,a){return new Promise((async(o,s)=>{try{if(!e)throw new Error("Database instance required");if(!r)throw new Error("Store name required");if(null==t)throw new Error("No key specified for database operation");let n=(await this.transReadOnly(e,r,a)).get(t);n.onsuccess=e=>o(e.target.result),n.onerror=e=>s(e.target.error)}catch(e){await this.#i({consoleMsg:"Error in database operation: ",err:e,userMsg:"Unable to perform database operation"})}}))}getAllStorePromise(e,r){return new Promise((async(t,a)=>{try{const o=(await this.transReadOnly(e,r)).getAll();o.onsuccess=e=>t(e.target.result),o.onerror=e=>a(e.target.error)}catch(e){await this.#i({consoleMsg:`Error accessing store ${r}: `,err:e,userMsg:"Unable to access data store"})}}))}getAllStoreByIndexPromise(e,r,t,a,o){return new Promise((async(s,n)=>{try{if(!e)throw new Error("Database instance required");if(!r)throw new Error("Store name required");if(!t)throw new Error("Index name required");if(null==a)throw new Error("No value specified for index operation");const i=(await this.transReadOnly(e,r,o)).index(t),c="trim_date"===t?a:"string"==typeof a?parseInt(a,10):a,E=i.getAll(IDBKeyRange.only(c));E.onsuccess=e=>s(e.target.result),E.onerror=e=>n(e.target.error)}catch(e){await this.#i({consoleMsg:"Error in database operation: ",err:e,userMessage:"Unable to perform database operation"})}}))}clearStorePromise(e,r,t){return new Promise((async(a,o)=>{try{if(!e)throw new Error("Database instance required");if(!r)throw new Error("Store name required");const s=(await this.transReadWrite(e,r,t)).clear();s.onsuccess=()=>a(s.result),s.onerror=e=>o(e.target.error)}catch(e){await this.#i({consoleMsg:"Error in database operation: ",err:e,userMsg:"Unable to perform database operation"})}}))}async addIndexDBPromise({data:e,storeName:r,clearStore:t=!1,transaction:a=null}){return new Promise((async(o,s)=>{try{if(!e)throw new Error("No data provided for store operation");if(!r)throw new Error("Store name required");const n=await(a instanceof IDBTransaction?a.db:this.openDBPromise()),i=await this.transReadWrite(n,r,a);if(t){i.clear().onerror=async e=>{e.preventDefault(),await this.#i({consoleMsg:`Error clearing store ${r}: `,err:e.target.error,userMsg:"Unable to add data"})}}const c=i.add(e);c.onsuccess=e=>o(e.target.result),c.onerror=e=>s(e.target.error)}catch(e){await this.#i({consoleMsg:"Error in database operation: ",err:e,userMsg:"Unable to perform database operation"})}}))}async putIndexDBPromise(e,r,t=null){return new Promise((async(a,o)=>{try{if(!e)throw new Error("No data provided for store operation");if(!r)throw new Error("Store name required");const s=await(t instanceof IDBTransaction?t.db:this.openDBPromise()),n=(await this.transReadWrite(s,r,t)).put(e);n.onsuccess=e=>a(e.target.result),n.onerror=e=>o(e.target.error)}catch(e){await this.#i({consoleMsg:"Error in database operation: ",err:e,userMsg:"Unable to perform database operation"})}}))}async deleteRecordPromise(e,r,t=null){try{const a=await(t instanceof IDBTransaction?t.db:this.openDBPromise()),o=(await this.transReadWrite(a,r,t)).delete(e);return await new Promise(((e,r)=>{o.onsuccess=()=>{e(!0)},o.onerror=e=>r(e.target.error)}))}catch(e){await this.#i({consoleMsg:"Error in database operation: ",err:e,userMsg:"Unable to perform database operation"})}}async deleteIDBDatabasePromise(){return new Promise(((e,r)=>{const t=indexedDB.deleteDatabase(this.#r);t.onsuccess=()=>{e(!0)},t.onerror=async r=>{await this.#i({consoleMsg:"Error deleting database: ",err:r,userMsg:"Unable to delete database"}),e(!1)}}))}}