// @ts-nocheck
export default class IndexedDBOperations{#e="ClientTrackerDB";#r=1;#t=null;#a={CLIENTLIST:{keyPath:"primaryKey",indexes:[{name:"cID",keyPath:"cID",unique:!1},{name:"trim_date",keyPath:"trim_date",unique:!1}]},MAXCLIENTID:{keyPath:"cID",unique:!0},MAXCLIENTPRIMARYKEY:{keyPath:"primaryKey",unique:!0},ADDCLIENT:{keyPath:"cID",unique:!0},EDITCLIENT:{keyPath:"primaryKey",unique:!0},DELETECLIENT:{keyPath:"cID"},ADDDUPLICATECLIENT:{keyPath:"primaryKey",unique:!0},DELETEDUPLICATECLIENT:{keyPath:"primaryKey",unique:!0},TRIMMING:{keyPath:"cID",unique:!0},MAXTRIMID:{keyPath:"trimID",unique:!0},ADDTRIMMING:{keyPath:"trimID",unique:!0},EDITTRIMMING:{keyPath:"cID"},DELETETRIMMING:{keyPath:"cID"},EDITMILEAGE:{keyPath:"mileageID",unique:!0},DELETEMILEAGE:{keyPath:"mileageID",unique:!0},EDITEXPENSES:{keyPath:"expID",unique:!0},DELETEEXPENSES:{keyPath:"expID",unique:!0},PERSONALNOTES:{keyPath:"notesID",unique:!0},ADDPERSONALNOTES:{keyPath:"notesID",unique:!0},EDITPERSONALNOTES:{keyPath:"notesID",unique:!0},DELETEPERSONALNOTES:{keyPath:"notesID",unique:!0},MAXPERSONALNOTESID:{keyPath:"notesID",unique:!0},MAXHORSEID:{keyPath:"hID",unique:!0},ADDHORSE:{keyPath:"hID",autoIncrement:!0,unique:!0},EDITHORSE:{keyPath:"hID"},DELETEHORSE:{keyPath:"hID"},USERSETTINGS:{autoIncrement:!0},DATETIME:{autoIncrement:!0},FARRIERPRICES:{autoIncrement:!0},MILEAGECHARGES:{autoIncrement:!0},SCHEDULINGOPTIONS:{autoIncrement:!0},COLOROPTIONS:{autoIncrement:!0},ERRORQUEUE:{autoIncrement:!0},DEFAULT:{autoIncrement:!0}};stores={MAXCLIENTID:"max_client_id",MAXCLIENTPRIMARYKEY:"max_client_primary_key",ADDCLIENT:"backup_add_client",EDITCLIENT:"backup_edit_client",DELETECLIENT:"backup_delete_client",ADDDUPLICATECLIENT:"backup_add_duplicate_client",DELETEDUPLICATECLIENT:"backup_delete_duplicate_client",USERSETTINGS:"user_settings",CLIENTLIST:"client_list",TRIMMING:"trimmings",MAXHORSEID:"max_horse_id",ADDHORSE:"backup_add_horse",EDITHORSE:"backup_edit_horse",DELETEHORSE:"backup_delete_horse",MAXTRIMID:"max_trim_id",ADDTRIMMING:"backup_add_trimming",EDITTRIMMING:"backup_edit_trimming",DELETETRIMMING:"backup_delete_trimming",ADDMILEAGE:"backup_add_mileage",EDITMILEAGE:"backup_edit_mileage",DELETEMILEAGE:"backup_delete_mileage",ADDEXPENSES:"backup_add_expenses",EDITEXPENSES:"backup_edit_expenses",DELETEEXPENSES:"backup_delete_expenses",PERSONALNOTES:"personal_notes",MAXPERSONALNOTESID:"max_personal_notes_id",ADDPERSONALNOTES:"backup_add_personal_notes",EDITPERSONALNOTES:"backup_edit_personal_notes",DELETEPERSONALNOTES:"backup_delete_personal_notes",DATETIME:"backup_date_time",FARRIERPRICES:"backup_farrier_prices",MILEAGECHARGES:"backup_mileage_charges",SCHEDULINGOPTIONS:"backup_scheduling_options",COLOROPTIONS:"backup_color_options",ERRORQUEUE:"error_queue"};async#o({consoleMsg:e,err:r,userMsg:t}){const{AppError:a}=await import("../errors/models/AppError.js");await a.process(r,{errorCode:a.Types.DATABASE_ERROR,userMessage:t,displayTarget:"page-msg"},!0)}async openDBPromise(){try{return this.#t||(this.#t=await new Promise(((e,r)=>{const t=indexedDB.open(this.#e,this.#r);t.onupgradeneeded=e=>this.#n(e),t.onsuccess=r=>e(r.target.result),t.onerror=()=>r(new Error("Failed to open database")),t.onblocked=()=>r(new Error("Database blocked - close other tabs"))}))),this.#t}catch(e){await this.#o({consoleMsg:"Database open failed: ",err:e,userMsg:"Unable to access local storage"})}}#n(e){const r=e.target.result;for(const[e,t]of Object.entries(this.stores))if(!r.objectStoreNames.contains(t)){const a=this.#a[e]??this.#a.DEFAULT;this.createStore(r,t,a)}}createStore(e,r,t){const a=e.createObjectStore(r,t);t.indexes&&t.indexes.forEach((e=>{a.createIndex(e.name,e.keyPath,{unique:e.unique})}))}async transReadWrite(e,r,t=null){try{const a=t||e.transaction(r,"readwrite");return a.onerror=e=>{console.error(`Transaction error in store ${r}:`,e),a.abort()},a.objectStore(r)}catch(e){await this.#o({consoleMsg:`Transaction error in store ${r}: `,err:e,userMsg:"Unable to access storage"})}}async transReadOnly(e,r,t=null){try{return(t||e.transaction(r,"readonly")).objectStore(r)}catch(e){await this.#o({consoleMsg:`Failed to access store ${r}: `,err:e,userMsg:"Unable to read from storage"})}}getLastKeyForID({store:e,tx:r=null}){return new Promise((async t=>{try{if(!e)throw new Error("Store name required");const a=r?.db||await this.openDBPromise(),o=(await this.transReadOnly(a,e,r)).getAll();o.onsuccess=e=>{const r=o.result;t(r[0]+1||1)},o.onerror=async r=>{r.preventDefault(),await this.#o({consoleMsg:`Failed to get last key from ${e}: `,err:r.target.error,userMsg:"Unable to generate new ID"})}}catch(e){await this.#o({consoleMsg:"Error in getLastKeyForID operation: ",err:e,userMsg:"Unable to perform database operation"})}}))}addStorePromise(e,r,t,a=!1,o){return new Promise((async(n,s)=>{try{if(!e)throw new Error("Database instance required");if(!t)throw new Error("Store name required");if(!r)throw new Error("No data provided for store operation");const i=await this.transReadWrite(e,t,o);if(a){i.clear().onerror=e=>s(e.target.error)}const c=i.add(r);c.onsuccess=e=>n(e.target.result),c.onerror=e=>s(e.target.error)}catch(e){await this.#o({consoleMsg:"Error in database operation: ",err:e,userMsg:"Unable to perform database operation"})}}))}putStorePromise(e,r,t,a=!1,o){return new Promise((async(n,s)=>{try{if(!e)throw new Error("Database instance required");if(!t)throw new Error("Store name required");if(!r)throw new Error("No data provided for store operation");const i=await this.transReadWrite(e,t,o);if(a){i.clear().onerror=async e=>{e.preventDefault(),await this.#o({consoleMsg:`Error clearing store ${t}: `,err:e.target.error,userMsg:"Unable to update data"})}}const c=i.put(r);c.onsuccess=e=>n(e.target.result),c.onerror=e=>s(e.target.error)}catch(e){await this.#o({consoleMsg:"Error in putStorePromise database operation: ",err:e,userMsg:"Unable to perform database operation"})}}))}getStorePromise(e,r,t,a){return new Promise((async(o,n)=>{try{if(!e)throw new Error("Database instance required");if(!r)throw new Error("Store name required");if(null==t)throw new Error("No key specified for database operation");let s=(await this.transReadOnly(e,r,a)).get(t);s.onsuccess=e=>o(e.target.result),s.onerror=e=>n(e.target.error)}catch(e){await this.#o({consoleMsg:"Error in database operation: ",err:e,userMsg:"Unable to perform database operation"})}}))}getAllStorePromise(e,r){return new Promise((async(t,a)=>{try{const o=(await this.transReadOnly(e,r)).getAll();o.onsuccess=e=>t(e.target.result),o.onerror=e=>a(e.target.error)}catch(e){await this.#o({consoleMsg:`Error accessing store ${r}: `,err:e,userMsg:"Unable to access data store"})}}))}getAllStoreByIndexPromise(e,r,t,a,o){return new Promise((async(n,s)=>{try{if(!e)throw new Error("Database instance required");if(!r)throw new Error("Store name required");if(!t)throw new Error("Index name required");if(null==a)throw new Error("No value specified for index operation");const i=(await this.transReadOnly(e,r,o)).index(t),c="trim_date"===t?a:"string"==typeof a?parseInt(a,10):a,E=i.getAll(IDBKeyRange.only(c));E.onsuccess=e=>n(e.target.result),E.onerror=e=>s(e.target.error)}catch(e){await this.#o({consoleMsg:"Error in database operation: ",err:e,userMessage:"Unable to perform database operation"})}}))}clearStorePromise(e,r,t){return new Promise((async(a,o)=>{try{if(!e)throw new Error("Database instance required");if(!r)throw new Error("Store name required");const n=(await this.transReadWrite(e,r,t)).clear();n.onsuccess=()=>a(n.result),n.onerror=e=>o(e.target.error)}catch(e){await this.#o({consoleMsg:"Error in database operation: ",err:e,userMsg:"Unable to perform database operation"})}}))}async addIndexDBPromise({data:e,storeName:r,clearStore:t=!1,transaction:a=null}){return new Promise((async(o,n)=>{try{if(!e)throw new Error("No data provided for store operation");if(!r)throw new Error("Store name required");const s=await(a instanceof IDBTransaction?a.db:this.openDBPromise()),i=await this.transReadWrite(s,r,a);if(t){i.clear().onerror=async e=>{e.preventDefault(),await this.#o({consoleMsg:`Error clearing store ${r}: `,err:e.target.error,userMsg:"Unable to add data"})}}const c=i.add(e);c.onsuccess=e=>o(e.target.result),c.onerror=e=>n(e.target.error)}catch(e){await this.#o({consoleMsg:"Error in database operation: ",err:e,userMsg:"Unable to perform database operation"})}}))}async putIndexDBPromise(e,r,t=null){return new Promise((async(a,o)=>{try{if(!e)throw new Error("No data provided for store operation");if(!r)throw new Error("Store name required");const n=await(t instanceof IDBTransaction?t.db:this.openDBPromise()),s=(await this.transReadWrite(n,r,t)).put(e);s.onsuccess=e=>a(e.target.result),s.onerror=e=>o(e.target.error)}catch(e){await this.#o({consoleMsg:"Error in database operation: ",err:e,userMsg:"Unable to perform database operation"})}}))}async deleteRecordPromise(e,r,t=null){try{const a=await(t instanceof IDBTransaction?t.db:this.openDBPromise()),o=(await this.transReadWrite(a,r,t)).delete(e);return await new Promise(((e,r)=>{o.onsuccess=()=>{e(!0)},o.onerror=e=>r(e.target.error)}))}catch(e){await this.#o({consoleMsg:"Error in database operation: ",err:e,userMsg:"Unable to perform database operation"})}}async deleteIDBDatabasePromise(){return new Promise(((e,r)=>{const t=indexedDB.deleteDatabase(this.#e);t.onsuccess=()=>{e(!0)},t.onerror=async r=>{await this.#o({consoleMsg:"Error deleting database: ",err:r,userMsg:"Unable to delete database"}),e(!1)}}))}}