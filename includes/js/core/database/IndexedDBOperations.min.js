// @ts-nocheck
import{AppError}from"../../errors/models/AppError.js";export default class IndexedDBOperations{#e="ClientTrackerDB";#r=1;#a=null;#t={CLIENTLIST:{keyPath:"primaryKey",indexes:[{name:"cID",keyPath:"cID",unique:!1},{name:"trim_date",keyPath:"trim_date",unique:!1}]},MAXCLIENTID:{keyPath:"cID",unique:!0},MAXCLIENTPRIMARYKEY:{keyPath:"primaryKey",unique:!0},ADDCLIENT:{keyPath:"cID",unique:!0},EDITCLIENT:{keyPath:"primaryKey",unique:!0},DELETECLIENT:{keyPath:"cID"},ADDDUPLICATECLIENT:{keyPath:"primaryKey",unique:!0},DELETEDUPLICATECLIENT:{keyPath:"primaryKey",unique:!0},TRIMMING:{keyPath:"cID",unique:!0},MAXTRIMID:{keyPath:"trimID",unique:!0},ADDTRIMMING:{keyPath:"trimID",unique:!0},EDITTRIMMING:{keyPath:"cID"},DELETETRIMMING:{keyPath:"cID"},EDITMILEAGE:{keyPath:"mileageID",unique:!0},DELETEMILEAGE:{keyPath:"mileageID",unique:!0},EDITEXPENSES:{keyPath:"expID",unique:!0},DELETEEXPENSES:{keyPath:"expID",unique:!0},PERSONALNOTES:{keyPath:"notesID",unique:!0},ADDPERSONALNOTES:{keyPath:"notesID",unique:!0},EDITPERSONALNOTES:{keyPath:"notesID",unique:!0},DELETEPERSONALNOTES:{keyPath:"notesID",unique:!0},MAXPERSONALNOTESID:{keyPath:"notesID",unique:!0},MAXHORSEID:{keyPath:"hID",unique:!0},ADDHORSE:{keyPath:"hID",autoIncrement:!0,unique:!0},EDITHORSE:{keyPath:"hID"},DELETEHORSE:{keyPath:"hID"},USERSETTINGS:{autoIncrement:!0},DATETIME:{autoIncrement:!0},FARRIERPRICES:{autoIncrement:!0},MILEAGECHARGES:{autoIncrement:!0},SCHEDULINGOPTIONS:{autoIncrement:!0},COLOROPTIONS:{autoIncrement:!0},ERRORQUEUE:{autoIncrement:!0},DEFAULT:{autoIncrement:!0}};stores={MAXCLIENTID:"max_client_id",MAXCLIENTPRIMARYKEY:"max_client_primary_key",ADDCLIENT:"backup_add_client",EDITCLIENT:"backup_edit_client",DELETECLIENT:"backup_delete_client",ADDDUPLICATECLIENT:"backup_add_duplicate_client",DELETEDUPLICATECLIENT:"backup_delete_duplicate_client",USERSETTINGS:"user_settings",CLIENTLIST:"client_list",TRIMMING:"trimmings",MAXHORSEID:"max_horse_id",ADDHORSE:"backup_add_horse",EDITHORSE:"backup_edit_horse",DELETEHORSE:"backup_delete_horse",MAXTRIMID:"max_trim_id",ADDTRIMMING:"backup_add_trimming",EDITTRIMMING:"backup_edit_trimming",DELETETRIMMING:"backup_delete_trimming",ADDMILEAGE:"backup_add_mileage",EDITMILEAGE:"backup_edit_mileage",DELETEMILEAGE:"backup_delete_mileage",ADDEXPENSES:"backup_add_expenses",EDITEXPENSES:"backup_edit_expenses",DELETEEXPENSES:"backup_delete_expenses",PERSONALNOTES:"personal_notes",MAXPERSONALNOTESID:"max_personal_notes_id",ADDPERSONALNOTES:"backup_add_personal_notes",EDITPERSONALNOTES:"backup_edit_personal_notes",DELETEPERSONALNOTES:"backup_delete_personal_notes",DATETIME:"backup_date_time",FARRIERPRICES:"backup_farrier_prices",MILEAGECHARGES:"backup_mileage_charges",SCHEDULINGOPTIONS:"backup_scheduling_options",COLOROPTIONS:"backup_color_options",ERRORQUEUE:"error_queue"};async#s({consoleMsg:e,err:r,userMsg:a}){const{AppError:t}=await import("../../errors/models/AppError.js");await t.process(r,{errorCode:t.Types.DATABASE_ERROR,userMessage:a,displayTarget:"page-msg"},!0)}async openDBPromise(){try{return this.#a||(this.#a=await new Promise(((e,r)=>{const a=indexedDB.open(this.#e,this.#r);a.onupgradeneeded=e=>this.#n(e),a.onsuccess=r=>e(r.target.result),a.onerror=()=>r(new Error("Failed to open database")),a.onblocked=()=>r(new Error("Database blocked - close other tabs"))}))),this.#a}catch(e){await this.#s({consoleMsg:"Database open failed: ",err:e,userMsg:"Unable to access local storage"})}}#n(e){const r=e.target.result;for(const[e,a]of Object.entries(this.stores))if(!r.objectStoreNames.contains(a)){const t=this.#t[e]??this.#t.DEFAULT;this.createStore(r,a,t)}}createStore(e,r,a){const t=e.createObjectStore(r,a);a.indexes&&a.indexes.forEach((e=>{t.createIndex(e.name,e.keyPath,{unique:e.unique})}))}async transReadWrite(e,r,a=null){try{const t=a||e.transaction(r,"readwrite");return t.onerror=e=>{console.error(`Transaction error in store ${r}:`,e),t.abort()},t.objectStore(r)}catch(e){await this.#s({consoleMsg:`Transaction error in store ${r}: `,err:e,userMsg:"Unable to access storage"})}}async transReadOnly(e,r,a=null){try{return(a||e.transaction(r,"readonly")).objectStore(r)}catch(e){await this.#s({consoleMsg:`Failed to access store ${r}: `,err:e,userMsg:"Unable to read from storage"})}}getLastKeyForID(e){return new Promise((async r=>{const a=(await this.openDBPromise()).transaction(e).objectStore(e).openCursor(null,"prev");a.onsuccess=e=>{const a=e.target.result;r(a?a.key+1:1)},a.onerror=async r=>{await this.#s({consoleMsg:`Failed to get last key from ${e}: `,err:r,userMsg:"Unable to generate new ID"})}}))}addStorePromise(e,r,a,t=!1,s){return new Promise((async n=>{try{const o=await this.transReadWrite(e,a,s);if(t){o.clear().onerror=async e=>{await this.#s({consoleMsg:`Error clearing store ${a}: `,err:e,userMsg:"Unable to add data"})}}const i=o.add(r);i.onsuccess=e=>n(e.target.result),i.onerror=async e=>{await this.#s({consoleMsg:`Error adding data to ${a}: `,err:e,userMsg:"Unable to add data"})}}catch(e){await this.#s({consoleMsg:`Error initializing store ${a}: `,err:e,userMsg:"Unable to add data"})}}))}putStorePromise(e,r,a,t=!1,s){return new Promise((async n=>{const o=await this.transReadWrite(e,a,s);t&&o.clear();const i=o.put(r);i.onsuccess=()=>n(i.result),i.onerror=async e=>{await this.#s({consoleMsg:`Error updating data in ${a}: `,err:e,userMsg:"Unable to update data"})}}))}getStorePromise(e,r,a,t){return new Promise((async s=>{let n=(await this.transReadOnly(e,r,t)).get(a);n.onsuccess=e=>{s(e.target.result)},n.onerror=async e=>{await this.#s({consoleMsg:`Error retrieving data from ${r}: `,err:e,userMsg:"Unable to retrieve data"})}}))}getAllStorePromise(e,r){return new Promise((async(a,t)=>{try{const t=(await this.transReadOnly(e,r)).getAll();t.onsuccess=e=>{a(e.target.result)},t.onerror=async e=>{await this.#s({consoleMsg:`Error retrieving data from ${r}: `,err:e,userMsg:"Unable to retrieve data"})}}catch(e){await this.#s({consoleMsg:`Error accessing store ${r}: `,err:e,userMsg:"Unable to access data store"}),t(e)}}))}getAllStoreByIndexPromise(e,r,a,t,s){return new Promise((async n=>{const o=(await this.transReadOnly(e,r,s)).index(a).openCursor(IDBKeyRange.only(t)),i=[];o.onsuccess=e=>{const r=e.target.result;r?(i.push({...r.value}),r.continue()):n(i)},o.onerror=async e=>{await this.#s({consoleMsg:`Error retrieving data from ${r}: `,err:e,userMsg:"Unable to retrieve data"})}}))}clearStorePromise(e,r,a){return new Promise((async t=>{const s=(await this.transReadWrite(e,r,a)).clear();s.onsuccess=()=>t(s.result),s.onerror=async e=>{await this.#s({consoleMsg:`Error clearing data from ${r}: `,err:e,userMsg:"Unable to clear data"})}}))}async addIndexDBPromise({data:e,storeName:r,clearStore:a=!1,transaction:t=null}){return new Promise((async(s,n)=>{try{const n=await(t instanceof IDBTransaction?t.db:this.openDBPromise()),o=await this.transReadWrite(n,r,t);if(a){o.clear().onerror=async e=>{await this.#s({consoleMsg:`Error clearing store ${r}: `,err:e,userMsg:"Unable to add data"})}}const i=o.add(e);i.onsuccess=e=>s(e.target.result),i.onerror=async e=>{await this.#s({consoleMsg:`Error adding data to ${r}: `,err:e,userMsg:"Unable to add data"})}}catch(e){await this.#s({consoleMsg:`Error initializing store ${r}: `,err:e,userMsg:"Unable to add data"}),n(e)}}))}async putIndexDBPromise(e,r,a=null){return new Promise((async(t,s)=>{try{const s=await(a instanceof IDBTransaction?a.db:this.openDBPromise()),n=(await this.transReadWrite(s,r,a)).put(e);n.onsuccess=()=>t(n.result),n.onerror=async e=>{await this.#s({consoleMsg:`Error updating data in ${r}: `,err:e,userMsg:"Unable to update data"})}}catch(e){await this.#s({consoleMsg:`Error initializing store ${r}: `,err:e,userMsg:"Unable to update data"}),s(e)}}))}async deleteRecordPromise(e,r,a=null){try{const t=await(a instanceof IDBTransaction?a.db:this.openDBPromise()),s=(await this.transReadWrite(t,r,a)).delete(e);return await new Promise(((e,a)=>{s.onsuccess=()=>{e(!0)},s.onerror=async e=>{await this.#s({consoleMsg:`Error deleting record from ${r}: `,err:e,userMsg:"Unable to delete record"})}}))}catch(e){await this.#s({consoleMsg:`Error deleting record from ${r}: `,err:e,userMsg:"Unable to delete record"})}}async deleteIDBDatabasePromise(){return new Promise(((e,r)=>{const a=indexedDB.deleteDatabase(this.#e);a.onsuccess=()=>{e(!0)},a.onerror=async r=>{await this.#s({consoleMsg:"Error deleting database: ",err:r,userMsg:"Unable to delete database"}),e(!1)}}))}}