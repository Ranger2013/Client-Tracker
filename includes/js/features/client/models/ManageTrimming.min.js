// @ts-nocheck
import IndexedDBOperations from"../../../core/database/IndexedDBOperations.js";import ManageClient from"./ManageClient.js";export default class ManageTrimming{static#e=null;#t;#i;#s=!1;constructor(e={debug:!1}){return ManageTrimming.#e?(void 0!==e.debug&&ManageTrimming.#e.setDebugMode(e.debug),ManageTrimming.#e):(this.#t=new IndexedDBOperations,this.#i=new ManageClient,this.#s=e.debug||!1,ManageTrimming.#e=this,this.#r("ManageTrimming singleton instance created"),this)}setDebugMode(e){this.#s=!!e}#r(...e){this.#s&&console.log("[ManageTrimming]",...e)}async handleAddTrimmingSession({cID:e,primaryKey:t,userData:i}){try{if(!i||!e||!t)throw new Error("Missing required data for trimming session");e="string"==typeof e?parseInt(e,10):e,t="string"==typeof t?parseInt(t,10):t;const[s,r]=await Promise.all([this.#i.getClientTrimmingInfo(e),this.#t.getLastKeyForID({store:this.#t.stores.MAXTRIMID})]);this.#r("Previous trims:",s),this.#r("Next trim ID:",r);const a=this.setTrimmingDataStructureForBackupData({cID:e,userData:i,trimID:r});this.#r("Backup Data Structure: ",a);const n=await this.setTrimmingStoreData({cID:e,prevTrims:s});this.#r("Trimming Store Data: ",n),a.horses=await this.extractHorseData(i),this.#r("Horse Data: ",a.horses);let o="";if("yes"===i?.receipt){this.#r("Sending receipt for trimming session: backupData: ",a);const e=await this.handleSendingReceipt(a);this.#r("Receipt Status: ",e),"ok"===e.status?(a.receipt_sent="yes",o="<div>Receipt sent successfully.</div>"):(a.receipt_sent="no",a.userData=i,o=`<div class="w3-text-red">${e.msg}</div>`)}return this.#r("Backup Data Structure after receipt: ",a),await this.addTrimSession(a,n),this.#r("AFTER ADD TRIMMING DATA."),await this.#i.updateClientSchedule({cID:e,primaryKey:t,userData:i}),{status:"ok",message:`Trimming/Shoeing session added successfully.${o}`}}catch(e){const{AppError:t}=await import("../../../core/errors/models/AppError.js");t.process(e,{errorCode:t.Types.PROCESSING_ERROR,userMessage:"Failed to add trimming session"},!0)}}setTrimmingDataStructureForBackupData({cID:e,userData:t,trimID:i}){return{add_trimming:!0,app_time:t.app_time,cID:e,date_trimmed:t.trim_date,next_trim_date:t.next_trim_date,number_horses:t.number_horses,invoice_sent:"no",mileage_cost:t?.mileage_cost||"0",paid:t?.paid||"no",payment_amount:""!==t.payment?t.payment:"0",receipt:t?.receipt||"no",session_notes:t?.session_notes||"",trimID:i}}async setTrimmingStoreData({cID:e,prevTrims:t}){return{cID:e,trimmings:t}}async handleSendingReceipt(e){try{this.#r("Getting imports all at once.");const[{getValidationToken:t},{dataAPI:i},{fetchData:s}]=await Promise.all([import("../../../tracker.js"),import("../../../core/network/api/apiEndpoints.js"),import("../../../core/network/services/network.js")]);this.#r("Imports: ",t,i,s);const r=t();this.#r("Validation Token: ",r),this.#r("Before we send the receipt.");const a=await s({api:i.receipt,data:e,token:r});return this.#r("Receipt Response: ",a),a}catch(e){return{status:"error",msg:"Could not send receipt while offline."}}}async extractHorseData({number_horses:e,...t}){try{return Object.entries(t).reduce(((e,[i,s])=>{const r=i.match(/^horse_list_(\d+)$/);if(!r)return e;const a=r[1],[n,o]=s.split(":"),m=e.find((e=>e.index===a))||{index:a,hID:Number(n),horse_name:o,type_trim:t[`service_cost_${a}`],acc:t[`accessories_${a}`]||[]};return[...e.filter((e=>e.index!==a)),m]}),[]).sort(((e,t)=>Number(e.index)-Number(t.index))).map((({index:e,...t})=>t))}catch(e){const{AppError:t}=await import("../../../core/errors/models/AppError.js");return await t.process(e,{errorCode:t.Types.PROCESSING_ERROR,userMessage:"Failed to process horse data",context:{component:"ManageTrimming",action:"extractHorseData"}},!0),[]}}async addTrimSession(e,t){try{const{cID:i,add_trimming:s,userData:r,...a}=e,{trimID:n}=e;t.trimmings.push(a);const o=await this.#t.openDBPromise(),m=o.transaction([this.#t.stores.MAXTRIMID,this.#t.stores.ADDTRIMMING,this.#t.stores.TRIMMING],"readwrite");return await Promise.all([this.#t.putStorePromise(o,e,this.#t.stores.ADDTRIMMING,!1,m),this.#t.putStorePromise(o,{trimID:n},this.#t.stores.MAXTRIMID,!0,m),this.#t.putStorePromise(o,t,this.#t.stores.TRIMMING,!1,m)]),await this.cleanupTrimmings(i),!0}catch(e){const{AppError:t}=await import("../../../core/errors/models/AppError.js");t.process(e,{errorCode:t.Types.DATABASE_ERROR,userMessage:"Failed to add trimming session",displayTarget:"form-msg"},!0)}}async cleanupTrimmings(e){try{const t=await this.#i.getClientTrimmingInfo(Number(e));if(t&&t.length>9){t.shift();const i=await this.setTrimmingStoreData({cID:e,prevTrims:t}),s=await this.#t.openDBPromise();this.#t.putStorePromise(s,i,this.#t.stores.TRIMMING)}}catch(e){const{handleError:t}=await import("../utils/error-messages/handleError.js");await t("cleanupTrimmingsError","Cleanup trimmings error: ",e)}}}