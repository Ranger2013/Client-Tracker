// @ts-nocheck
import IndexedDBOperations from"../../../core/database/IndexedDBOperations.js";import ManageClient from"./ManageClient.js";export default class ManageTrimming{static#e=null;#t;#i;#r=!1;constructor(e={debug:!1}){return ManageTrimming.#e?(void 0!==e.debug&&ManageTrimming.#e.setDebugMode(e.debug),ManageTrimming.#e):(this.#t=new IndexedDBOperations,this.#i=new ManageClient,this.#r=e.debug||!1,ManageTrimming.#e=this,this.#s("ManageTrimming singleton instance created"),this)}setDebugMode(e){this.#r=!!e}#s(...e){this.#r&&console.log("[ManageTrimming]",...e)}async handleAddTrimmingSession({cID:e,primaryKey:t,userData:i}){try{if(!i||!e||!t)throw new Error("Missing required data for trimming session");"string"==typeof e&&(e=parseInt(e,10));const[r,s]=await Promise.all([this.#i.getClientTrimmingInfo(e),this.#t.getLastKeyForID({store:this.#t.stores.MAXTRIMID})]);this.#s("Previous trims:",r),this.#s("Next trim ID:",s);const a=this.setTrimmingDataStructureForBackupData({cID:e,userData:i,trimID:s});this.#s("Backup Data Structure: ",a);const n=await this.setTrimmingStoreData({cID:e,prevTrims:r});this.#s("Trimming Store Data: ",n),a.horses=await this.extractHorseData(i),this.#s("Horse Data: ",a.horses);let o="";if("yes"===i?.receipt){this.#s("Sending receipt for trimming session");const e=await this.handleSendingReceipt(a);this.#s("Receipt Status: ",e),"ok"===e.status?(a.receipt_sent="yes",o="<div>Receipt sent successfully.</div>"):(a.receipt_sent="no",o=`<div class="w3-text-red">${e.msg}</div>`)}return this.#s("Backup Data Structure after receipt: ",a),await this.addTrimSession(a,n),this.#s("AFTER ADD TRIMMING DATA."),await this.#i.updateClientSchedule({cID:e,primaryKey:t,userData:i}),{status:"ok",message:`Trimming/Shoeing session added successfully.${o}`}}catch(e){const{AppError:t}=await import("../../../core/errors/models/AppError.js");t.process(e,{errorCode:t.Types.PROCESSING_ERROR,userMessage:"Failed to add trimming session"},!0)}}setTrimmingDataStructureForBackupData({cID:e,userData:t,trimID:i}){return{add_trimming:!0,trimID:i,cID:e,mileage_cost:t?.mileage_cost||"0",receipt:t?.receipt||"no",session_notes:t?.session_notes||"",payment_amount:""!==t.payment?t.payment:"0",date_trimmed:t.trim_date,paid:t?.paid||"no",invoice_sent:"no"}}async setTrimmingStoreData({cID:e,prevTrims:t}){return{cID:e,trimmings:t}}async handleSendingReceipt(e){try{const[{getValidationToken:t},{dataAPI:i},{fetchData:r}]=await Promise.all([import("../../../tracker.js"),import("../../../core/network/api/apiEndpoints.js"),import("../../../core/network/services/network.js")]),s=t();this.#s("Before we send the receipt.");const a=await r({api:i.receipt,data:e,token:s});return this.#s("Receipt Response: ",a),a}catch(e){return{status:"error",msg:"Could not send receipt while offline."}}}async extractHorseData({number_horses:e,...t}){try{return Object.entries(t).reduce(((e,[i,r])=>{const s=i.match(/^horse_list_(\d+)$/);if(!s)return e;const a=s[1],[n,o]=r.split(":"),m=e.find((e=>e.index===a))||{index:a,hID:Number(n),horse_name:o,type_trim:t[`service_cost_${a}`],acc:t[`accessories_${a}`]||[]};return[...e.filter((e=>e.index!==a)),m]}),[]).sort(((e,t)=>Number(e.index)-Number(t.index))).map((({index:e,...t})=>t))}catch(e){const{AppError:t}=await import("../../../core/errors/models/AppError.js");return await t.process(e,{errorCode:t.Types.PROCESSING_ERROR,userMessage:"Failed to process horse data",context:{component:"ManageTrimming",action:"extractHorseData"}},!0),[]}}async addTrimSession(e,t){try{const i=await this.#t.openDBPromise(),r=i.transaction([this.#t.stores.MAXTRIMID,this.#t.stores.ADDTRIMMING,this.#t.stores.TRIMMING],"readwrite"),s=this.#t.putStorePromise(i,e,this.#t.stores.ADDTRIMMING,!1,r),a=this.#t.putStorePromise(i,{trimID:e.trimID},this.#t.stores.MAXTRIMID,!0,r),n=e.cID;delete e.add_trimming,delete e.userData,t.trimmings.push(e),this.#s("Add Trim Session: trimmingStoreData after backupData push: ",t);const o=this.#t.putStorePromise(i,t,this.#t.stores.TRIMMING,!1,r);return await Promise.all([s,a,o]),this.#s("Before cleanup Trimmings."),await this.cleanupTrimmings(n),this.#s("After cleanup Trimmings."),!0}catch(e){const{AppError:t}=await import("../../../core/errors/models/AppError.js");t.process(e,{errorCode:t.Types.DATABASE_ERROR,userMessage:"Failed to add trimming session",displayTarget:"form-msg"},!0)}}async cleanupTrimmings(e){try{const t=await this.#i.getClientTrimmingInfo(Number(e));if(t&&t.length>9){t.shift();const i=await this.setTrimmingStoreData({cID:e,prevTrims:t}),r=await this.#t.openDBPromise();this.#t.putStorePromise(r,i,this.#t.stores.TRIMMING)}}catch(e){const{handleError:t}=await import("../utils/error-messages/handleError.js");await t("cleanupTrimmingsError","Cleanup trimmings error: ",e)}}}