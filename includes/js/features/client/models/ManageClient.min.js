// @ts-nocheck
import IndexedDBOperations from"../../../core/database/IndexedDBOperations.js";export default class ManageClient{#e;#t=null;#r=!1;#i=null;constructor(){this.#e=new IndexedDBOperations}async#s(){if(!this.#r)try{const e=await this.#e.openDBPromise();this.#t=await this.#e.getAllStorePromise(e,this.#e.stores.CLIENTLIST),this.#r=!0}catch(e){const{AppError:t}=await import("../../core/errors/models/AppError.js");throw new t("Client data initialization failed",{originalError:e,errorCode:t.Types.INITIALIZATION_ERROR,userMessage:null,shouldLog:!0})}}async getClientInfo({primaryKey:e}){return await this.#s(),this.#t.find((t=>t.primaryKey===parseInt(e,10)))}async getAllDuplicateClients(){try{const e=await this.#e.openDBPromise(),t=await this.#e.getAllStorePromise(e,this.#e.stores.CLIENTLIST);return this.#o(t)}catch(e){const{handleError:t}=await import("../../../../../old-js-code/js/utils/error-messages/handleError.js");return await t({filename:"getAllDuplicateClientsError",consoleMsg:"Get duplicate clients error: ",err:e,userMsg:"Unable to retrieve duplicate clients"}),[]}}#o(e){const t=Object.entries(e.reduce(((e,t)=>(e[t.cID]=(e[t.cID]||0)+1,e)),{})).filter((([e,t])=>t>1)).map((([e])=>parseInt(e,10)));return e.filter((e=>t.includes(e.cID)))}async addNewClient(e){try{if(!e)throw new Error("No user data provided.");const[t,r]=await Promise.all([this.#e.getLastKeyForID(this.#e.stores.MAXCLIENTID),this.#e.getLastKeyForID(this.#e.stores.MAXCLIENTPRIMARYKEY)]);e.cID=t,e.primaryKey=r;const i=await this.#e.openDBPromise(),s=i.transaction([this.#e.stores.CLIENTLIST,this.#e.stores.ADDCLIENT,this.#e.stores.MAXCLIENTID,this.#e.stores.MAXCLIENTPRIMARYKEY],"readwrite");return await Promise.all([this.#e.addStorePromise(i,e,this.#e.stores.CLIENTLIST,!1,s),this.#e.putStorePromise(i,e,this.#e.stores.ADDCLIENT,!1,s),this.#e.putStorePromise(i,{cID:t},this.#e.stores.MAXCLIENTID,!0,s),this.#e.putStorePromise(i,{primaryKey:r},this.#e.stores.MAXCLIENTPRIMARYKEY,!0,s)]),!0}catch(e){const{AppError:t}=await import("../../core/errors/models/AppError.js");throw new t("Failed to add new client",{originalError:e,errorCode:t.Types.DATABASE_ERROR,userMessage:null,shouldLog:!0})}}async editClient(e,t,r){try{if(!t||!r)throw new Error("No cID or primaryKey provided.");const i=await this.#e.openDBPromise(),s=i.transaction([this.#e.stores.CLIENTLIST,this.#e.stores.EDITCLIENT],"readwrite"),o=await this.#e.getAllStoreByIndexPromise(i,this.#e.stores.CLIENTLIST,"cID",t,s);return await Promise.all([...o.map((n=>{const d={...e,horses:o[0].horses||[],cID:t,primaryKey:r};return n.primaryKey!==r&&Object.assign(d,{trim_cycle:n.trim_cycle,trim_date:n.trim_date,app_time:n.app_time,primaryKey:n.primaryKey}),this.#e.putStorePromise(i,d,this.#e.stores.CLIENTLIST,!1,s)})),this.#e.putStorePromise(i,{...e,edit_client:!0,cID:t,primaryKey:r},this.#e.stores.EDITCLIENT,!1,s)]),!0}catch(e){const{AppError:t}=await import("../../core/errors/models/AppError.js");throw new t("Failed to edit client",{originalError:e,errorCode:t.Types.DATABASE_ERROR,userMessage:null,shouldLog:!0})}}async deleteClient(e,t){try{if(!t||!e)throw new Error("No primary key or cID provided.");t=parseInt(t,10);const r=await this.#e.openDBPromise(),i=r.transaction([this.#e.stores.CLIENTLIST,this.#e.stores.DELETECLIENT],"readwrite"),s=await this.#e.getAllStoreByIndexPromise(r,this.#e.stores.CLIENTLIST,"cID",e,i),o=s[0]?.client_name,n=s.map((e=>{this.#e.deleteRecordPromise(e.primaryKey,this.#e.stores.CLIENTLIST,i),this.#e.deleteRecordPromise(e.cID,this.#e.stores.TRIMMING,i)})),d={delete_client:!0,client_name:o,cID:e};return n.push(this.#e.putStorePromise(r,d,this.#e.stores.DELETECLIENT,!1,i)),await Promise.all(n),{status:!0,msg:"Client has been removed.",type:"delete-client"}}catch(e){const{handleError:t}=await import("../../../../../old-js-code/js/utils/error-messages/handleError.js");return await t("deleteClientError","Delete client error: ",e),{status:!1,msg:`Unable to delete client at this time.<br>${helpDeskTicket}`}}}async addDuplicateClient(e){try{const{app_time:t,duplicate_client:r,next_trim_date:i,trim_cycle:s}=e,o=await this.#e.getLastKeyForID(this.#e.stores.MAXCLIENTPRIMARYKEY),n=await this.#e.openDBPromise(),d=n.transaction([this.#e.stores.CLIENTLIST,this.#e.stores.ADDDUPLICATECLIENT,this.#e.stores.MAXCLIENTPRIMARYKEY],"readwrite"),a=[],l=await this.#e.getStorePromise(n,this.#e.stores.CLIENTLIST,parseInt(r,10),d),h={...l,primaryKey:o,app_time:t,trim_date:i,trim_cycle:s};return a.push(this.#e.addStorePromise(n,h,this.#e.stores.CLIENTLIST,!1,d)),h.add_duplicateClient=!0,a.push(this.#e.putStorePromise(n,h,this.#e.stores.ADDDUPLICATECLIENT,!1,d)),a.push(this.#e.putStorePromise(n,{primaryKey:o},this.#e.stores.MAXCLIENTPRIMARYKEY,!0,d)),await Promise.all(a),{status:"success",msg:`${l.client_name} has been duplicated successfully.`}}catch(e){const{handleError:t}=await import("../../../../../old-js-code/js/utils/error-messages/handleError.js");return await t("addDuplicateClientError","Add duplicate client error: ",e),{status:!1,msg:`Unable to add duplicate client at this time.<br>${helpDeskTicket}`}}}async deleteDuplicateClient(e){try{if(!primaryKey)throw new Error("No primary key provided.");e.primaryKey=parseInt(primaryKey,10);const t=await this.#e.openDBPromise(),r=t.transaction([this.#e.stores.CLIENTLIST,this.#e.stores.DELETEDUPLICATECLIENT],"readwrite"),i={...e},s=[];return s.push(this.#e.deleteRecordPromise(e.primaryKey,this.#e.stores.CLIENTLIST,r)),s.push(this.#e.putStorePromise(t,i,this.#e.stores.DELETEDUPLICATECLIENT,!1,r)),await Promise.all(s),{status:!0,msg:"Duplicate client has been removed."}}catch(e){const{handleError:t}=await import("../../../../../old-js-code/js/utils/error-messages/handleError.js");return await t("deleteDuplicateClientError","Delete duplicate client error: ",e),{status:!1,msg:`Unable to delete duplicate client at this time.<br>${helpDeskTicket}`}}}async addNewHorse(e,t,r){try{if(!t||!r)throw new Error("No cID or primaryKey provided.");const i=await this.#e.getLastKeyForID(this.#e.stores.MAXHORSEID),s=await this.#e.openDBPromise(),o=s.transaction([this.#e.stores.CLIENTLIST,this.#e.stores.ADDHORSE,this.#e.stores.MAXHORSEID],"readwrite"),n=await this.#e.getAllStoreByIndexPromise(s,this.#e.stores.CLIENTLIST,"cID",t,o),d=n[0]?.horses||[],a=n[0]?.client_name;if(d.some((t=>t.horse_name.toLowerCase()===e.toLowerCase())))return{status:!1,msg:`${e} is already listed.`};const l={hID:i,horse_name:e};d.push(l);const h=[];for(const e of n){const t={...e,horses:d};h.push(this.#e.putStorePromise(s,t,this.#e.stores.CLIENTLIST,!1,o))}const c={add_newHorse:!0,horse_name:e,client_name:a,cID:t,hID:i};return h.push(this.#e.putStorePromise(s,c,this.#e.stores.ADDHORSE,!1,o)),h.push(this.#e.putStorePromise(s,{hID:i},this.#e.stores.MAXHORSEID,!0,o)),await Promise.all(h),{status:!0,msg:`${e} has been added.`}}catch(t){const{handleError:r}=await import("../../../../../old-js-code/js/utils/error-messages/handleError.js");return await r("addNewHorseError","Add new horse error: ",t),{status:!1,msg:`Unable to add ${e} at this time.<br>${helpDeskTicket}`}}}async editClientHorse(e,t,r){try{if(!e||!t)throw new Error("No horse id or client id provided.");"string"==typeof e&&(e=Number(e));const i=await this.#e.openDBPromise(),s=i.transaction([this.#e.stores.CLIENTLIST,this.#e.stores.EDITHORSE],"readwrite"),o=await this.#e.getAllStoreByIndexPromise(i,this.#e.stores.CLIENTLIST,"cID",t,s),n=o[0]?.client_name,d=[];for(const t of o){const o=t.horses.map((t=>t.hID===Number(e)?{...t,horse_name:r}:t)),n={...t,horses:o};d.push(this.#e.putStorePromise(i,n,this.#e.stores.CLIENTLIST,!1,s))}const a={hID:e,cID:t,horse_name:r,edit_clientHorse:!0,client_name:n};return d.push(this.#e.putStorePromise(i,a,this.#e.stores.EDITHORSE,!1,s)),await Promise.all(d),{status:!0,msg:`${r} has been updated.`}}catch(e){const{handleError:t}=await import("../../../../../old-js-code/js/utils/error-messages/handleError.js");return await t("editClientHorseError","Edit client horse error: ",e),{status:!1,msg:`Unable to edit ${r} at this time.<br>${helpDeskTicket}`}}}async deleteClientHorse(e,t){try{if(!e||!t)throw new Error("No horse id or client id provided.");"string"==typeof e&&(e=Number(e)),"string"==typeof t&&(t=Number(t));const r=await this.#e.openDBPromise(),i=r.transaction([this.#e.stores.CLIENTLIST,this.#e.stores.DELETEHORSE],"readwrite"),s=await this.#e.getAllStoreByIndexPromise(r,this.#e.stores.CLIENTLIST,"cID",t,i),o=s[0]?.client_name,n=[];for(const t of s){const s=t.horses.filter((t=>t.hID!==Number(e))),o={...t,horses:s};n.push(this.#e.putStorePromise(r,o,this.#e.stores.CLIENTLIST,!1,i))}const d={hID:e,cID:t,delete_clientHorse:!0,client_name:o};return n.push(this.#e.putStorePromise(r,d,this.#e.stores.DELETEHORSE,!1,i)),await Promise.all(n),i.oncomplete=()=>{console.log("Transaction completed successfully.")},i.onerror=e=>{throw console.error("Transaction failed:",e),new Error("Transaction failed: "+e.target.error)},{status:!0,msg:"Horse has been deleted."}}catch(e){const{handleError:t}=await import("../../../../../old-js-code/js/utils/error-messages/handleError.js");return await t("deleteClientHorseError","Delete client horse error: ",e),{status:!1,msg:`Unable to delete horse at this time.<br>${helpDeskTicket}`}}}async getClientScheduleList(){try{const e=await this.#e.openDBPromise();return await this.#e.getAllStorePromise(e,this.#e.stores.CLIENTLIST)||[]}catch(e){const{handleError:t}=await import("../../../../../old-js-code/js/utils/error-messages/handleError.js");throw await t("getClientScheduleListError","Get client schedule list error: ",e),e}}async getAllClientsTrimmingInfo(){try{const e=await this.#e.openDBPromise(),t=await this.#e.getAllStorePromise(e,this.#e.stores.TRIMMING);return t?.trimmings||[]}catch(e){const{handleError:t}=await import("../../../../../old-js-code/js/utils/error-messages/handleError.js");throw await t("getAllClientsTrimmingInfoError","Get all clients trimming info error: ",e),e}}async getClientTrimmingInfo(e){try{const t=await this.#e.openDBPromise(),r=await this.#e.getStorePromise(t,this.#e.stores.TRIMMING,e);return r?.trimmings||[]}catch(e){const{handleError:t}=await import("../../../../../old-js-code/js/utils/error-messages/handleError.js");return await t("getClientTrimmingInfoError","Get client trimming info error: ",e),[]}}async updateClientSchedule(e){try{const{next_trim_date:t,app_time:r,...i}=e,s=await this.#e.openDBPromise(),o=s.transaction([this.#e.stores.CLIENTLIST,this.#e.stores.EDITCLIENT],"readwrite"),n=[],d={...await this.#e.getStorePromise(s,this.#e.stores.CLIENTLIST,e.primaryKey,o),app_time:r,trim_date:t};return n.push(this.#e.putStorePromise(s,d,this.#e.stores.CLIENTLIST,!1,o)),d.edit_client=!0,n.push(this.#e.putStorePromise(s,d,this.#e.stores.EDITCLIENT,!1,o)),await Promise.all(n),{status:!0,msg:"Client schedule updated successfully."}}catch(e){const{handleError:t}=await import("../../../../../old-js-code/js/utils/error-messages/handleError.js");return await t("updateClientScheduleError","Update client schedule error: ",e),{status:!1,msg:`Unable to update the client schedule.<br>${helpDeskTicket}`}}}async updateClientData(e){try{return await this.#n(e),this.#t=null,this.#r=!1,!0}catch(e){const{AppError:t}=await import("../../core/errors/models/AppError.js");throw new t("Failed to update client data",{originalError:e,errorCode:t.Types.DATABASE_ERROR,userMessage:null,shouldLog:!0})}}async#n(e){const t=await this.#e.openDBPromise(),r=t.transaction([this.#e.stores.CLIENTLIST],"readwrite");return await this.#e.putStorePromise(t,e,this.#e.stores.CLIENTLIST,!1,r),!0}}