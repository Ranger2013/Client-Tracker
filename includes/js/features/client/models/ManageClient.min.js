// @ts-nocheck
import IndexedDBOperations from"../../../core/database/IndexedDBOperations.js";import DateHelper from"../../../core/utils/date/DateHelper.js";export default class ManageClient{static#e=null;#r;#t;#i=null;#s=!1;#o=null;#n=!1;constructor(e={debug:!1}){return ManageClient.#e?(void 0!==e.debug&&ManageClient.#e.setDebugMode(e.debug),ManageClient.#e):(this.#r=new IndexedDBOperations,this.#t=new DateHelper,this.#n=e.debug||!1,ManageClient.#e=this,this.#d("ManageClient singleton instance created."),this)}setDebugMode(e){this.#n=!!e}#d(...e){this.#n&&console.log("[ManageClient]",...e)}async#a(){if(!this.#s)try{const e=await this.#r.openDBPromise();this.#i=await this.#r.getAllStorePromise(e,this.#r.stores.CLIENTLIST),this.#s=!0}catch(e){const{AppError:r}=await import("../../../core/errors/models/AppError.js");r.process(e,{errorCode:r.Types.INITIALIZATION_ERROR,userMessage:"Client data initialization failed"},!0)}}async getClientInfo({primaryKey:e}){return await this.#a(),this.#i.find((r=>r.primaryKey===parseInt(e,10)))}async getAllDuplicateClients(){try{const e=await this.#r.openDBPromise(),r=await this.#r.getAllStorePromise(e,this.#r.stores.CLIENTLIST);return this.#p(r)}catch(e){const{AppError:r}=await import("../../../core/errors/models/AppError.js");return r.process(e,{errorCode:r.Types.DATABASE_ERROR,userMessage:"Unable to retrieve duplicate clients"},!0),[]}}#p(e){const r=Object.entries(e.reduce(((e,r)=>(e[r.cID]=(e[r.cID]||0)+1,e)),{})).filter((([e,r])=>r>1)).map((([e])=>parseInt(e,10)));return e.filter((e=>r.includes(e.cID)))}async addNewClient(e){try{if(this.#d("Adding new client: userData: ",e),!e)throw new Error("No user data provided.");const[r,t]=await Promise.all([this.#r.getLastKeyForID({store:this.#r.stores.MAXCLIENTID}),this.#r.getLastKeyForID({store:this.#r.stores.MAXCLIENTPRIMARYKEY})]);this.#d("New cID: ",r),this.#d("New Primary Key: ",t),e.cID=r,e.primaryKey=t;const i={...e,add_newClient:!0},s=await this.#r.openDBPromise(),o=s.transaction([this.#r.stores.CLIENTLIST,this.#r.stores.ADDCLIENT,this.#r.stores.MAXCLIENTID,this.#r.stores.MAXCLIENTPRIMARYKEY],"readwrite");return await Promise.all([this.#r.addStorePromise(s,e,this.#r.stores.CLIENTLIST,!1,o),this.#r.putStorePromise(s,i,this.#r.stores.ADDCLIENT,!1,o),this.#r.putStorePromise(s,{cID:r},this.#r.stores.MAXCLIENTID,!0,o),this.#r.putStorePromise(s,{primaryKey:t},this.#r.stores.MAXCLIENTPRIMARYKEY,!0,o)]),!0}catch(e){const{AppError:r}=await import("../../../core/errors/models/AppError.js");r.process(e,{errorCode:r.Types.DATABASE_ERROR,userMessage:null},!0)}}async editClient(e,r,t){try{if(!r||!t)throw new Error("No cID or primaryKey provided.");r="string"==typeof r?parseInt(r,10):r,t="string"==typeof t?parseInt(t,10):t;const i=await this.#r.openDBPromise(),s=i.transaction([this.#r.stores.CLIENTLIST,this.#r.stores.EDITCLIENT],"readwrite"),o=await this.#r.getAllStoreByIndexPromise(i,this.#r.stores.CLIENTLIST,"cID",r,s);return await Promise.all([...o.map((n=>{const d={...e,horses:o[0].horses||[],cID:r,primaryKey:t};return this.#d("NewClientData: ",d),n.primaryKey!==t&&Object.assign(d,{trim_cycle:n.trim_cycle,trim_date:n.trim_date,app_time:n.app_time,primaryKey:t}),this.#r.putStorePromise(i,d,this.#r.stores.CLIENTLIST,!1,s)})),this.#r.putStorePromise(i,{...e,edit_client:!0,cID:r,primaryKey:t},this.#r.stores.EDITCLIENT,!1,s)]),this.#i=null,this.#s=!1,!0}catch(e){const{AppError:r}=await import("../../../core/errors/models/AppError.js");r.process(e,{errorCode:r.Types.DATABASE_ERROR,userMessage:null},!0)}}async deleteClient(e,r){try{if(!r||!e)throw new Error("No primary key or cID provided.");r=parseInt(r,10);const t=await this.#r.openDBPromise(),i=t.transaction([this.#r.stores.CLIENTLIST,this.#r.stores.DELETECLIENT],"readwrite"),s=await this.#r.getAllStoreByIndexPromise(t,this.#r.stores.CLIENTLIST,"cID",e,i),o=s[0]?.client_name,n=s.map((e=>{this.#r.deleteRecordPromise(e.primaryKey,this.#r.stores.CLIENTLIST,i),this.#r.deleteRecordPromise(e.cID,this.#r.stores.TRIMMING,i)})),d={delete_client:!0,client_name:o,cID:e};return n.push(this.#r.putStorePromise(t,d,this.#r.stores.DELETECLIENT,!1,i)),await Promise.all(n),{status:!0,msg:"Client has been removed.",type:"delete-client"}}catch(e){const{AppError:r}=await import("../../../core/errors/models/AppError.js");r.process(e,{errorCode:r.Types.DATABASE_ERROR,userMessage:null},!0)}}async addDuplicateClient(e){try{const{app_time:r,select_client:t,next_trim_date:i,trim_cycle:s}=e,o=parseInt(t.split(":")[0],10),n=await this.#r.getLastKeyForID({store:this.#r.stores.MAXCLIENTPRIMARYKEY}),d=await this.#r.openDBPromise(),a=d.transaction([this.#r.stores.CLIENTLIST,this.#r.stores.ADDDUPLICATECLIENT,this.#r.stores.MAXCLIENTPRIMARYKEY],"readwrite"),p={...await this.#r.getStorePromise(d,this.#r.stores.CLIENTLIST,parseInt(o,10),a),primaryKey:n,app_time:r,trim_date:i,trim_cycle:s},c={...p,add_duplicateClient:!0};return await Promise.all([this.#r.addStorePromise(d,p,this.#r.stores.CLIENTLIST,!1,a),this.#r.putStorePromise(d,c,this.#r.stores.ADDDUPLICATECLIENT,!1,a),this.#r.putStorePromise(d,{primaryKey:n},this.#r.stores.MAXCLIENTPRIMARYKEY,!0,a)]),!0}catch(e){const{AppError:r}=await import("../../../core/errors/models/AppError.js");r.process(e,{errorCode:r.Types.DATABASE_ERROR,userMessage:null},!0)}}async deleteDuplicateClient(e){try{if(!e)throw new Error("No primary key provided.");"string"==typeof e&&(e=parseInt(e,10));const r=await this.#r.openDBPromise(),t=r.transaction([this.#r.stores.CLIENTLIST,this.#r.stores.DELETEDUPLICATECLIENT],"readwrite"),i={delete_duplicate_client:!0,primaryKey:e};return await Promise.all([this.#r.deleteRecordPromise(e,this.#r.stores.CLIENTLIST,t),this.#r.putStorePromise(r,i,this.#r.stores.DELETEDUPLICATECLIENT,!1,t)]),!0}catch(e){const{AppError:r}=await import("../../../core/errors/models/AppError.js");r.process(e,{errorCode:r.Types.DATABASE_ERROR,userMessage:null},!0)}}async getClientHorses({primaryKey:e}){try{if(!e)throw new Error("No primaryKey provided.");const r=await this.getClientInfo({primaryKey:e});return r?.horses||[]}catch(e){const{AppError:r}=await import("../../../core/errors/models/AppError.js");r.process(e,{errorCode:r.Types.DATABASE_ERROR,userMessage:null},!0)}}async addNewHorse({userData:e,cID:r,primaryKey:t,clientName:i}){try{if(!r||!t)throw new Error("No cID or primaryKey provided.");const s=await this.#r.getLastKeyForID({store:this.#r.stores.MAXHORSEID});this.#d("New Horse ID: ",s);const o=await this.#r.openDBPromise(),n=o.transaction([this.#r.stores.CLIENTLIST,this.#r.stores.ADDHORSE,this.#r.stores.MAXHORSEID],"readwrite"),d=await this.#r.getAllStoreByIndexPromise(o,this.#r.stores.CLIENTLIST,"cID",r,n),a=d[0]?.horses||[],p={hID:s,client_name:i,horse_name:e.horse_name,horse_type:e.horse_type,service_type:e.service_type,trim_cycle:e.trim_cycle};return a.push(p),await Promise.all([...d.map((e=>this.#r.putStorePromise(o,{...e,horses:a},this.#r.stores.CLIENTLIST,!1,n))),this.#r.putStorePromise(o,{...p,add_newHorse:!0,cID:r},this.#r.stores.ADDHORSE,!1,n),this.#r.putStorePromise(o,{hID:s},this.#r.stores.MAXHORSEID,!0,n)]),this.#i=null,this.#s=!1,!0}catch(e){const{AppError:r}=await import("../../../core/errors/models/AppError.js");r.process(e,{errorCode:r.Types.DATABASE_ERROR,userMessage:null},!0)}}async editClientHorse({cID:e,userData:r}){try{const{hID:t,primaryKey:i,...s}=r,o=parseInt(t,10);if(isNaN(o)||!e)throw new Error("No horse id or client id provided.");const n=await this.#r.openDBPromise(),d=n.transaction([this.#r.stores.CLIENTLIST,this.#r.stores.EDITHORSE],"readwrite"),a=await this.#r.getAllStoreByIndexPromise(n,this.#r.stores.CLIENTLIST,"cID",e,d),p=a[0]?.client_name,c={edit_clientHorse:!0,hID:o,cID:parseInt(e,10),client_name:p,...s};return await Promise.all([...a.map((e=>{const r=e.horses.map((e=>{if(e.hID===o){return{...e,hID:o,...s}}return e}));return this.#r.putStorePromise(n,{...e,horses:r},this.#r.stores.CLIENTLIST,!1,d)})),this.#r.putStorePromise(n,c,this.#r.stores.EDITHORSE,!1,d)]),this.#i=null,this.#s=!1,!0}catch(e){const{AppError:r}=await import("../../../core/errors/models/AppError.js");r.process(e,{errorCode:r.Types.DATABASE_ERROR,userMessage:null},!0)}}async deleteClientHorse({hID:e,cID:r}){try{if(!e||!r)throw new Error("No horse id or client id provided.");"string"==typeof e&&(e=Number(e)),"string"==typeof r&&(r=Number(r));const t=await this.#r.openDBPromise(),i=t.transaction([this.#r.stores.CLIENTLIST,this.#r.stores.DELETEHORSE],"readwrite"),s=await this.#r.getAllStoreByIndexPromise(t,this.#r.stores.CLIENTLIST,"cID",r,i),o=s[0]?.client_name,n=[];for(const r of s){const s=r.horses.filter((r=>r.hID!==Number(e))),o={...r,horses:s};n.push(this.#r.putStorePromise(t,o,this.#r.stores.CLIENTLIST,!1,i))}const d={hID:e,cID:r,delete_clientHorse:!0,client_name:o};return n.push(this.#r.putStorePromise(t,d,this.#r.stores.DELETEHORSE,!1,i)),await Promise.all(n),i.onerror=e=>{throw console.error("Transaction failed:",e),new Error("Transaction failed: "+e.target.error)},this.#i=null,this.#s=!1,!0}catch(e){const{AppError:r}=await import("../../../core/errors/models/AppError.js");r.process(e,{errorCode:r.Types.DATABASE_ERROR,userMessage:null},!0)}}async getClientScheduleList({active:e="all"}={}){try{const r=await this.#r.openDBPromise(),t=await this.#r.getAllStorePromise(r,this.#r.stores.CLIENTLIST);if("all"!==e){return Array.from(t).filter((r=>{const t=this.#t.fromString(r.trim_date),i=this.#t.today();return r.active===e&&t.isSameOrAfter(i)}))}return t||[]}catch(e){const{AppError:r}=await import("../../../core/errors/models/AppError.js");r.process(e,{errorCode:r.Types.DATABASE_ERROR,userMessage:null},!0)}}async getClientScheduleByTrimDate(e){try{this.#d("In getClientScheduleByTrimDate: trimDate: ",e);const r=await this.#r.openDBPromise(),t=await this.#r.getAllStoreByIndexPromise(r,this.#r.stores.CLIENTLIST,"trim_date",e);return this.#d("In getClientScheduleByTrimDate: clientList: ",t),t||[]}catch(e){const{AppError:r}=await import("../../../core/errors/models/AppError.js");r.process(e,{errorCode:r.Types.DATABASE_ERROR,userMessage:null},!0)}}async getAllClientsTrimmingInfo(){try{const e=await this.#r.openDBPromise(),r=await this.#r.getAllStorePromise(e,this.#r.stores.TRIMMING);return r?.trimmings||[]}catch(e){const{AppError:r}=await import("../../../core/errors/models/AppError.js");r.process(e,{errorCode:r.Types.DATABASE_ERROR,userMessage:null},!0)}}async getClientTrimmingInfo(e){try{e="string"==typeof e?parseInt(e,10):e;const r=await this.#r.openDBPromise(),t=await this.#r.getStorePromise(r,this.#r.stores.TRIMMING,e);return console.log("In getClientTrimmingInfo: trimmingInfo: ",t),t?.trimmings||[]}catch(e){const{AppError:r}=await import("../../../core/errors/models/AppError.js");return r.process(e,{errorCode:r.Types.DATABASE_ERROR,userMessage:null}),[]}}async updateClientTrimmingInfo({cID:e,trimmingInfo:r}){try{if(!e||!r)throw new Error("No cID or trimmingInfo provided.");const t={cID:parseInt(e,10),trimmings:r},i=await this.#r.openDBPromise();await this.#r.putStorePromise(i,t,this.#r.stores.TRIMMING)}catch(e){const{AppError:r}=await import("../../../core/errors/models/AppError.js");r.process(e,{errorCode:r.Types.DATABASE_ERROR,userMessage:null},!0)}}async updateClientSchedule({cID:e,primaryKey:r,userData:t}){try{if(!e||!r||!t)throw new Error("No cID, primaryKey, or userData provided.");const{next_trim_date:i,app_time:s,...o}=t,n=await this.#r.openDBPromise(),d=n.transaction([this.#r.stores.CLIENTLIST,this.#r.stores.EDITCLIENT],"readwrite"),a={...await this.#r.getStorePromise(n,this.#r.stores.CLIENTLIST,parseInt(r,10),d),cID:e,primaryKey:r,app_time:s,trim_date:i},p={...a,edit_client:!0};return await Promise.all([this.#r.putStorePromise(n,a,this.#r.stores.CLIENTLIST,!1,d),this.#r.putStorePromise(n,p,this.#r.stores.EDITCLIENT,!1,d)]),this.#i=null,this.#s=!1,!0}catch(e){const{AppError:r}=await import("../../../core/errors/models/AppError.js");return r.handleError(e,{errorCode:r.Types.DATABASE_ERROR,userMessage:"We had an issue updating the client's new schedule. Update their schedule through the edit client and please report this issue."},!0),!1}}async updateClientData(e){try{return await this.#c(e),this.#i=null,this.#s=!1,!0}catch(e){const{AppError:r}=await import("../../core/errors/models/AppError.js");throw new r("Failed to update client data",{originalError:e,errorCode:r.Types.DATABASE_ERROR,userMessage:null,shouldLog:!0})}}async#c(e){const r=await this.#r.openDBPromise(),t=r.transaction([this.#r.stores.CLIENTLIST],"readwrite");return await this.#r.putStorePromise(r,e,this.#r.stores.CLIENTLIST,!1,t),!0}}