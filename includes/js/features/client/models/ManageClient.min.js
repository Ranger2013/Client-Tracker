// @ts-nocheck
import IndexedDBOperations from"../../../core/database/IndexedDBOperations.js";export default class ManageClient{#e;#r=null;#s=!1;#t=null;constructor(){this.#e=new IndexedDBOperations}async#i(){if(!this.#s)try{const e=await this.#e.openDBPromise();this.#r=await this.#e.getAllStorePromise(e,this.#e.stores.CLIENTLIST),this.#s=!0}catch(e){console.log("In ManageClient.js: ",e);const{AppError:r}=await import("../../../core/errors/models/AppError.js");r.process(e,{errorCode:r.Types.INITIALIZATION_ERROR,userMessage:"Client data initialization failed"},!0)}}async getClientInfo({primaryKey:e}){return await this.#i(),this.#r.find((r=>r.primaryKey===parseInt(e,10)))}async getAllDuplicateClients(){try{const e=await this.#e.openDBPromise(),r=await this.#e.getAllStorePromise(e,this.#e.stores.CLIENTLIST);return this.#o(r)}catch(e){const{AppError:r}=await import("../../../core/errors/models/AppError.js");return r.process(e,{errorCode:r.Types.DATABASE_ERROR,userMessage:"Unable to retrieve duplicate clients"},!0),[]}}#o(e){const r=Object.entries(e.reduce(((e,r)=>(e[r.cID]=(e[r.cID]||0)+1,e)),{})).filter((([e,r])=>r>1)).map((([e])=>parseInt(e,10)));return e.filter((e=>r.includes(e.cID)))}async addNewClient(e){try{if(!e)throw new Error("No user data provided.");const[r,s]=await Promise.all([this.#e.getLastKeyForID(this.#e.stores.MAXCLIENTID),this.#e.getLastKeyForID(this.#e.stores.MAXCLIENTPRIMARYKEY)]);e.cID=r,e.primaryKey=s;const t={...e,add_newClient:!0},i=await this.#e.openDBPromise(),o=i.transaction([this.#e.stores.CLIENTLIST,this.#e.stores.ADDCLIENT,this.#e.stores.MAXCLIENTID,this.#e.stores.MAXCLIENTPRIMARYKEY],"readwrite");return await Promise.all([this.#e.addStorePromise(i,e,this.#e.stores.CLIENTLIST,!1,o),this.#e.putStorePromise(i,t,this.#e.stores.ADDCLIENT,!1,o),this.#e.putStorePromise(i,{cID:r},this.#e.stores.MAXCLIENTID,!0,o),this.#e.putStorePromise(i,{primaryKey:s},this.#e.stores.MAXCLIENTPRIMARYKEY,!0,o)]),!0}catch(e){const{AppError:r}=await import("../../../core/errors/models/AppError.js");r.process(e,{errorCode:r.Types.DATABASE_ERROR,userMessage:null},!0)}}async editClient(e,r,s){try{if(!r||!s)throw new Error("No cID or primaryKey provided.");const t=await this.#e.openDBPromise(),i=t.transaction([this.#e.stores.CLIENTLIST,this.#e.stores.EDITCLIENT],"readwrite"),o=await this.#e.getAllStoreByIndexPromise(t,this.#e.stores.CLIENTLIST,"cID",r,i);return await Promise.all([...o.map((n=>{const d={...e,horses:o[0].horses||[],cID:r,primaryKey:s};return n.primaryKey!==s&&Object.assign(d,{trim_cycle:n.trim_cycle,trim_date:n.trim_date,app_time:n.app_time,primaryKey:n.primaryKey}),this.#e.putStorePromise(t,d,this.#e.stores.CLIENTLIST,!1,i)})),this.#e.putStorePromise(t,{...e,edit_client:!0,cID:r,primaryKey:s},this.#e.stores.EDITCLIENT,!1,i)]),!0}catch(e){const{AppError:r}=await import("../../../core/errors/models/AppError.js");r.process(e,{errorCode:r.Types.DATABASE_ERROR,userMessage:null},!0)}}async deleteClient(e,r){try{if(!r||!e)throw new Error("No primary key or cID provided.");r=parseInt(r,10);const s=await this.#e.openDBPromise(),t=s.transaction([this.#e.stores.CLIENTLIST,this.#e.stores.DELETECLIENT],"readwrite"),i=await this.#e.getAllStoreByIndexPromise(s,this.#e.stores.CLIENTLIST,"cID",e,t),o=i[0]?.client_name,n=i.map((e=>{this.#e.deleteRecordPromise(e.primaryKey,this.#e.stores.CLIENTLIST,t),this.#e.deleteRecordPromise(e.cID,this.#e.stores.TRIMMING,t)})),d={delete_client:!0,client_name:o,cID:e};return n.push(this.#e.putStorePromise(s,d,this.#e.stores.DELETECLIENT,!1,t)),await Promise.all(n),{status:!0,msg:"Client has been removed.",type:"delete-client"}}catch(e){const{AppError:r}=await import("../../../core/errors/models/AppError.js");r.process(e,{errorCode:r.Types.DATABASE_ERROR,userMessage:null},!0)}}async addDuplicateClient(e){try{const{app_time:r,duplicate_client:s,next_trim_date:t,trim_cycle:i}=e,o=await this.#e.getLastKeyForID(this.#e.stores.MAXCLIENTPRIMARYKEY),n=await this.#e.openDBPromise(),d=n.transaction([this.#e.stores.CLIENTLIST,this.#e.stores.ADDDUPLICATECLIENT,this.#e.stores.MAXCLIENTPRIMARYKEY],"readwrite"),a=[],p=await this.#e.getStorePromise(n,this.#e.stores.CLIENTLIST,parseInt(s,10),d),c={...p,primaryKey:o,app_time:r,trim_date:t,trim_cycle:i};return a.push(this.#e.addStorePromise(n,c,this.#e.stores.CLIENTLIST,!1,d)),c.add_duplicateClient=!0,a.push(this.#e.putStorePromise(n,c,this.#e.stores.ADDDUPLICATECLIENT,!1,d)),a.push(this.#e.putStorePromise(n,{primaryKey:o},this.#e.stores.MAXCLIENTPRIMARYKEY,!0,d)),await Promise.all(a),{status:"success",msg:`${p.client_name} has been duplicated successfully.`}}catch(e){const{AppError:r}=await import("../../../core/errors/models/AppError.js");r.process(e,{errorCode:r.Types.DATABASE_ERROR,userMessage:null},!0)}}async deleteDuplicateClient(e){try{if(!primaryKey)throw new Error("No primary key provided.");e.primaryKey=parseInt(primaryKey,10);const r=await this.#e.openDBPromise(),s=r.transaction([this.#e.stores.CLIENTLIST,this.#e.stores.DELETEDUPLICATECLIENT],"readwrite"),t={...e},i=[];return i.push(this.#e.deleteRecordPromise(e.primaryKey,this.#e.stores.CLIENTLIST,s)),i.push(this.#e.putStorePromise(r,t,this.#e.stores.DELETEDUPLICATECLIENT,!1,s)),await Promise.all(i),{status:!0,msg:"Duplicate client has been removed."}}catch(e){const{AppError:r}=await import("../../../core/errors/models/AppError.js");r.process(e,{errorCode:r.Types.DATABASE_ERROR,userMessage:null},!0)}}async addNewHorse(e,r,s){try{if(!r||!s)throw new Error("No cID or primaryKey provided.");const t=await this.#e.getLastKeyForID(this.#e.stores.MAXHORSEID),i=await this.#e.openDBPromise(),o=i.transaction([this.#e.stores.CLIENTLIST,this.#e.stores.ADDHORSE,this.#e.stores.MAXHORSEID],"readwrite"),n=await this.#e.getAllStoreByIndexPromise(i,this.#e.stores.CLIENTLIST,"cID",r,o),d=n[0]?.horses||[],a=n[0]?.client_name;if(d.some((r=>r.horse_name.toLowerCase()===e.toLowerCase())))return{status:!1,msg:`${e} is already listed.`};const p={hID:t,horse_name:e};d.push(p);const c=[];for(const e of n){const r={...e,horses:d};c.push(this.#e.putStorePromise(i,r,this.#e.stores.CLIENTLIST,!1,o))}const l={add_newHorse:!0,horse_name:e,client_name:a,cID:r,hID:t};return c.push(this.#e.putStorePromise(i,l,this.#e.stores.ADDHORSE,!1,o)),c.push(this.#e.putStorePromise(i,{hID:t},this.#e.stores.MAXHORSEID,!0,o)),await Promise.all(c),{status:!0,msg:`${e} has been added.`}}catch(e){const{AppError:r}=await import("../../../core/errors/models/AppError.js");r.process(e,{errorCode:r.Types.DATABASE_ERROR,userMessage:null},!0)}}async editClientHorse(e,r,s){try{if(!e||!r)throw new Error("No horse id or client id provided.");"string"==typeof e&&(e=Number(e));const t=await this.#e.openDBPromise(),i=t.transaction([this.#e.stores.CLIENTLIST,this.#e.stores.EDITHORSE],"readwrite"),o=await this.#e.getAllStoreByIndexPromise(t,this.#e.stores.CLIENTLIST,"cID",r,i),n=o[0]?.client_name,d=[];for(const r of o){const o=r.horses.map((r=>r.hID===Number(e)?{...r,horse_name:s}:r)),n={...r,horses:o};d.push(this.#e.putStorePromise(t,n,this.#e.stores.CLIENTLIST,!1,i))}const a={hID:e,cID:r,horse_name:s,edit_clientHorse:!0,client_name:n};return d.push(this.#e.putStorePromise(t,a,this.#e.stores.EDITHORSE,!1,i)),await Promise.all(d),{status:!0,msg:`${s} has been updated.`}}catch(e){const{AppError:r}=await import("../../../core/errors/models/AppError.js");r.process(e,{errorCode:r.Types.DATABASE_ERROR,userMessage:null},!0)}}async deleteClientHorse(e,r){try{if(!e||!r)throw new Error("No horse id or client id provided.");"string"==typeof e&&(e=Number(e)),"string"==typeof r&&(r=Number(r));const s=await this.#e.openDBPromise(),t=s.transaction([this.#e.stores.CLIENTLIST,this.#e.stores.DELETEHORSE],"readwrite"),i=await this.#e.getAllStoreByIndexPromise(s,this.#e.stores.CLIENTLIST,"cID",r,t),o=i[0]?.client_name,n=[];for(const r of i){const i=r.horses.filter((r=>r.hID!==Number(e))),o={...r,horses:i};n.push(this.#e.putStorePromise(s,o,this.#e.stores.CLIENTLIST,!1,t))}const d={hID:e,cID:r,delete_clientHorse:!0,client_name:o};return n.push(this.#e.putStorePromise(s,d,this.#e.stores.DELETEHORSE,!1,t)),await Promise.all(n),t.oncomplete=()=>{console.log("Transaction completed successfully.")},t.onerror=e=>{throw console.error("Transaction failed:",e),new Error("Transaction failed: "+e.target.error)},{status:!0,msg:"Horse has been deleted."}}catch(e){const{AppError:r}=await import("../../../core/errors/models/AppError.js");r.process(e,{errorCode:r.Types.DATABASE_ERROR,userMessage:null},!0)}}async getClientScheduleList(){try{const e=await this.#e.openDBPromise();return await this.#e.getAllStorePromise(e,this.#e.stores.CLIENTLIST)||[]}catch(e){const{AppError:r}=await import("../../../core/errors/models/AppError.js");r.process(e,{errorCode:r.Types.DATABASE_ERROR,userMessage:null},!0)}}async getClientScheduleByTrimDate(e){try{const r=await this.#e.openDBPromise();return await this.#e.getAllStoreByIndexPromise(r,this.#e.stores.CLIENTLIST,"trim_date",e)||[]}catch(e){console.log("In getClientScheduleByTrimDate.js: ",e);const{AppError:r}=await import("../../../core/errors/models/AppError.js");r.process(e,{errorCode:r.Types.DATABASE_ERROR,userMessage:null},!0)}}async getAllClientsTrimmingInfo(){try{const e=await this.#e.openDBPromise(),r=await this.#e.getAllStorePromise(e,this.#e.stores.TRIMMING);return r?.trimmings||[]}catch(e){const{AppError:r}=await import("../../../core/errors/models/AppError.js");r.process(e,{errorCode:r.Types.DATABASE_ERROR,userMessage:null},!0)}}async getClientTrimmingInfo(e){try{const r=await this.#e.openDBPromise(),s=await this.#e.getStorePromise(r,this.#e.stores.TRIMMING,e);return s?.trimmings||[]}catch(e){console.log("In getClientTrimmingInfo.js: ",e);const{AppError:r}=await import("../../../core/errors/models/AppError.js");return r.process(e,{errorCode:r.Types.DATABASE_ERROR,userMessage:null}),[]}}async updateClientSchedule(e){try{const{next_trim_date:r,app_time:s,...t}=e,i=await this.#e.openDBPromise(),o=i.transaction([this.#e.stores.CLIENTLIST,this.#e.stores.EDITCLIENT],"readwrite"),n=[],d={...await this.#e.getStorePromise(i,this.#e.stores.CLIENTLIST,e.primaryKey,o),app_time:s,trim_date:r};return n.push(this.#e.putStorePromise(i,d,this.#e.stores.CLIENTLIST,!1,o)),d.edit_client=!0,n.push(this.#e.putStorePromise(i,d,this.#e.stores.EDITCLIENT,!1,o)),await Promise.all(n),{status:!0,msg:"Client schedule updated successfully."}}catch(e){console.log("In updateClientSchedule.js: ",e);const{AppError:r}=await import("../../../core/errors/models/AppError.js");r.process(e,{errorCode:r.Types.DATABASE_ERROR,userMessage:null},!0)}}async updateClientData(e){try{return await this.#n(e),this.#r=null,this.#s=!1,!0}catch(e){const{AppError:r}=await import("../../core/errors/models/AppError.js");throw new r("Failed to update client data",{originalError:e,errorCode:r.Types.DATABASE_ERROR,userMessage:null,shouldLog:!0})}}async#n(e){const r=await this.#e.openDBPromise(),s=r.transaction([this.#e.stores.CLIENTLIST],"readwrite");return await this.#e.putStorePromise(r,e,this.#e.stores.CLIENTLIST,!1,s),!0}}