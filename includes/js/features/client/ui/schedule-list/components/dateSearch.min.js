// @ts-nocheck
const DAYS=["sunday","monday","tuesday","wednesday","thursday","friday","saturday"],MONTHS={jan:1,january:1,feb:2,february:2,mar:3,march:3,apr:4,april:4,may:5,jun:6,june:6,jul:7,july:7,aug:8,august:8,sep:9,september:9,oct:10,october:10,nov:11,november:11,dec:12,december:12};let userDateFormat=null;export async function matchesDateSearch({searchText:e,searchValue:t,manageUser:r}){try{if(!(e=e.toLowerCase().trim()))return!0;const[a,s]=t.split(" ");if(DAYS.includes(e))return s===e;const n=new Date(a);n.setUTCHours(0,0,0,0);for(const[t,r]of Object.entries(MONTHS))if(e===t||t.startsWith(e))return n.getUTCMonth()+1===r;const{date_format:o}=await r.getDateTimeOptions(),c=parseFlexibleDate(e,o);return c?(c.setUTCHours(0,0,0,0),c.getTime()===n.getTime()):DAYS.some((t=>t.includes(e)))||Object.keys(MONTHS).some((t=>t.includes(e)))}catch(e){const{AppError:t}=await import("../../../../../core/errors/models/AppError.min.js");t.process(e,{errorCode:t.Types.INITIALIZATION_ERROR,userMessage:"Search functionality not available at the moment."},!0)}}function parseFlexibleDate(e,t){const r=e.replace(/[^\d\s]/g,""),a={"Y-m-d":{pattern:/^(\d{4})[\s-]*(\d{1,2})[\s-]*(\d{1,2})$/,order:[0,1,2]},"m-d-Y":{pattern:/^(\d{1,2})[\s-]*(\d{1,2})[\s-]*(\d{4})$/,order:[2,0,1]},"d-m-Y":{pattern:/^(\d{1,2})[\s-]*(\d{1,2})[\s-]*(\d{4})$/,order:[2,1,0]}},s=a[t]||a["Y-m-d"],n=r.match(s.pattern);if(n){const[e,...t]=n,[r,a,o]=s.order.map((e=>t[e]));return new Date(r,a-1,o)}const o=r.match(/^(\d{1,2})[\s-]*(\d{1,2})$/);if(o){const[e,r,a]=o,s=(new Date).getFullYear(),n="m-d-Y"===t,c=new Date(s,(n?r:a)-1,n?a:r);return c.setHours(0,0,0,0),c}return null}function compareDates(e,t){return!(!e||!t)&&e.toISOString().split("T")[0]===t.toISOString().split("T")[0]}export function invalidateDateFormatCache(){userDateFormat=null}